<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>编程时的最佳做法</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="GameMaker Studio 2编程时的一些最佳做法的页面" />
  <meta name="rh-index-keywords" content="编程时的最佳做法" />
  <meta name="search-keywords" content="最佳实践" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>编程时的最佳做法</h1><p>在此页面上，我们将介绍游戏编程时的一些“最佳做法”，同时对<span class="notranslate">GameMaker Studio 2</span>的内部工作原理进行一些说明。但是，在继续之前，需要注意两个非常重要的观点：</p><ul class="colour"><li>这只是一个<em>指南</em>，而不是一劳永逸的100％完美的编写游戏的方法！这里提到的内容通常更多地是在组织和微观优化方面，当您对<span class="notranslate">GML</span>感到满意并认为合适时，应将它们纳入您的编程习惯中。</li><li>如果您的游戏运行良好，并且对目前的状况感到满意，那么<em>不要急于更改所有内容以挤出一些额外的FPS</em> 。您必须在可读性，灵活性和模块化代码与更改事物所需的时间和精力以及最终的总体收益之间取得平衡。基本上，如果它没有损坏，请不要对其进行修复，并保留您在此处为下一个项目学到的东西。</li></ul><p>话虽如此，让我们继续研究一些编写可以随时应用的<span class="notranslate">GML</span><br/></p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">程式风格</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot">在编写代码时，每个人都有自己的<em>风格</em>。编程的样式是放置方括号的方式，行的缩进方式以及变量的声明和命名方式等，对于使代码对其他人（以及将来的自己，一段时间后又不得不回到这个项目）。</p><p class="dropspot">有很多很多的<a href="http://en.wikipedia.org/wiki/Programming_style">编程风格</a>，有些人会认为他们是最好的使用，但事实是，几乎所有的风格是好的，只要你使用它的时候是<strong>一致的</strong>，它是<em>明确的</em>，<em>明显的</em>所有东西都是和做。</p><p class="dropspot"><img alt="Code Style Example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Style_Example.png" />上图是脚本中函数声明的示例，用于说明上述要点。您可以看到它使用JSDoc样式注释清楚地解释了所有功能，并且编码样式一致，具有4个空格缩进，用于本地var的下划线，记录的输出等。</p><p class="dropspot">还要注意，尽管脚本编辑器允许您将代码折叠在每个打开/关闭括号中，但是您可以使用 <span class="inline">#region</span>和 <span class="inline">#endregion</span>标记来分隔代码的各个部分，并大大提高了可读性，尤其是在处理包含多个功能的较大脚本时。区域也可以被注释-请参见手册中此页面的“编辑”部分）：</p><p class="dropspot"><img alt="Example Of Using Regions" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Regions.png" />在编写代码时，您应该意识到，在编译最终游戏时， <span class="notranslate">GameMaker Studio 2</span>会去除注释，删除不必要的换行符和空格，替换为常量/宏/枚举值，并且通常会将您的代码压缩为该过程的一部分。这意味着您可以根据需要在代码周围添加尽可能多的空格，而不必担心使注释简短或只使用很少的注释。</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">使用局部变量</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot">从以上有关编程风格的观点出发，许多初学者要做的一件事是将尽可能多的代码塞入一行代码中。例如：</p><p class="code">draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y)));</p><p class="dropspot">虽然不是完全不可读，但效率很低（ <span class="inline">point_direction()</span>例如，该函数被调用了两次），并且看起来很凌乱且笨拙。最好将其表示为：</p><p class="code">var p_dir = point_direction(x, y, mouse_x, mouse_y);<br/> var local_x = x + lengthdir_x(100, p_dir);<br/> var local_y = y + lengthdir_y(100, p_dir);<br/> draw_sprite(sprite_index, image_index, local_x, local_y);</p><p class="dropspot">创建这些局部变量所需的内存和资源可以忽略不计，而您（或以后阅读代码的其他任何人）从其清晰性中获得的即时好处则远远超过了它们。同样的想法也应应用于函数，在该函数中应为输入变量分配合理的名称，并在需要时使用清晰的格式和局部变量，以使其尽可能可读。</p><p class="dropspot">局部变量可以在游戏中快速处理，因此请充分利用它们，如果表达式在代码块或脚本中出现两次或两次以上，请考虑为其创建局部变量。使用<a class="glossterm" data-glossterm="YoYo编译器（YYC）"
        href="#"><span class="notranslate">YoYo</span>编译器（YYC）</a>目标时，如果您引用 <span class="inline">global</span>函数或代码块中的实例变量或实例变量的不同时间，在代码开始时将它们分配给局部变量，然后引用该局部变量特别有益，因为这样可以提供更好的性能。</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">数组</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot"><a href="../GameMaker_Language/GML_Overview/Arrays.htm">阵列</a>使用速度快，并且比数据结构所需的内存更少，但是可以进一步优化它们。创建数组时，会根据其大小为它分配内存，因此，即使您不打算稍后再填充它，也应首先尝试将其初始化为最大大小。例如，如果您知道需要一个数组来容纳最多100个值，则可以使用<a href="../GameMaker_Language/GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a>功能：</p><p class="code">array = array_create(100, 0);</p><p class="dropspot">这会将内存分配到一个“块”中，所有数组值均设置为默认值0，并有助于保持快速运行，否则每次将新值添加到数组时，都必须重新分配整个内存再次。</p><p class="note"><strong>注意</strong>：在HTML5目标上，像这样分配数组不适用，因此您应从0初始化该目标的数组！您可以通过检查os_browser变量来轻松处理此问题，例如：</p><p class="code"><span style="padding-left:1px;">if (os_browser == browser_not_a_browser)<br/>
    {<br/>
    array_create(100, 0);<br/>
    }<br/>
else<br/>
    {<br/>
    for (var i = 0; i &lt; 100; ++i;)<br/>
        {<br/>
        array[i] = 0;<br/>
        }<br/>
    }</span></p><p class="dropspot">您还可以通过将用于变量的变量设置为0来释放与数组关联的内存。因此，要从上面的代码示例中清除该数组，您只需使用：</p><p class="code">array = 0;</p><p class="dropspot">还要注意，数组是<strong>通过引用传递的</strong>，但是在进行更改时将复制整个内容（这种行为称为<strong>write on copy</strong> ）。因此，如果将数组传递给函数，则是传递<em>对原始数组的引用</em>，并且从数组中读取的任何值都将来自原始源。这样既好又快，但是如果您需要修改任何数组值，则数组本身在写入时将被复制，并且所做的任何更改都<strong>需要从函数中返回，否则它们将丢失</strong>。这要慢得多，并且会占用更多的内存，因此请小心如何在函数中使用数组。</p><p class="dropspot">但是，您可以通过使用特殊的数组<a href="../GameMaker_Language/GML_Overview/Accessors.htm">访问器来避免此写行为副本。</a><span class="inline">@</span> ，因为这样可以直接访问基础数组。例如：</p><p class="code">// Call a function, passing our array<br/> my_function(my_array);
    </p><p class="code">// The function looks like this:<br/>
      <br/> function my_function(_a)<br/> {
      <br/> // The array will be copied and the copy modified,<br/> // requiring you to use &quot;return _a&quot;, later<br/> _a[0] = 100;<br/> // This will modify the ORIGINAL array directly and<br/> // does not require it to be returned<br/> _a[@0]
      = 100;<br/> }
    </p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">数据结构</a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot">在<span class="notranslate">GameMaker Studio 2</span><a href="../GameMaker_Language/GML_Reference/Data_Structures/Data_Structures.htm">数据结构</a>已经过优化，比以前的<span class="notranslate">GameMaker</span>版本快很多。当不使用它们来释放内存时，仍然需要清理（销毁）它们，它们的速度仍然比数组慢，但是其易用性和处理它们包含的数据的额外功能通常会超过最小的速度差异，所以不要害怕在游戏中使用它们。</p><p class="dropspot">应当指出，在所有数据结构中，尤其是DS Maps都可以快速读取和写入数据，这使其成为所有类型任务的绝佳选择。</p><p class="dropspot">前面我们提到的<a href="../GameMaker_Language/GML_Overview/Accessors.htm">存取</a>为数组，但它们也可用于数据结构，它可以帮助清理你的代码，使它更容易阅读。</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">碰撞</a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot"><span class="notranslate">GameMaker Studio 2</span>有<a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/Collisions.htm">多种处理冲突的方法</a>，其中大多数附带了一些额外的CPU开销。这 <span class="inline">collision_</span>和 <span class="inline">point_</span>功能， <span class="inline">place_</span>功能，以及 <span class="inline">instance_</span>所有功能都依赖于<a class="glossterm" data-glossterm="边框" href="#">房间内具有给定类型的所有实例的边界框</a>检查，并且尽管引擎内置了一些优化来限制这些检查，但碰撞从来都不是最有效的方法。如果您开始使用精确的碰撞，性能也会变得非常差，因为您不仅要进行边界框检查，而且还要进行逐像素检查，这确实非常慢。有一个<span class="notranslate">YoYo Games</span>技术博客在这里讨论此问题：</p><ul class="dropspotlist"><li class="dropspot"><a href="https://www.yoyogames.com/blog/32/the-hazards-of-precise-collision-detection">精确碰撞检测的危害</a></li></ul><p class="dropspot">这并不是说您不应该使用这些功能，因为它们会非常方便。但是，您应该知道要使用哪些工具以及何时使用它们，因为它们的工作方式略有不同，并且速度会有所不同。粗略的经验法则是 <span class="inline">place_</span>功能比 <span class="inline">instance_</span>功能，比 <span class="inline">collision_</span>和 <span class="inline">point_</span>功能，因此请阅读手册中有关每种类型的功能的页面，并确保针对每种情况选择最合适的功能。</p><p class="dropspot">或者，研究创建基于<strong>图块的碰撞系统</strong>，可以使用<a href="../GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/Tile_Map_Layers.htm">tilemap函数</a>甚至自定义2D数组或DS网格来创建该系统。这些将非常快，将有助于提高游戏速度。但是，如果您使用的地形不规则，或者墙壁和对象未与网格对齐，则可能不合适。您可以从以下视频链接中找到有关瓦片地图碰撞的非常简单的教程</p><ul class="dropspotlist"><li class="dropspot"><a href="https://youtu.be/UyKdQQ3UR_0"><span class="notranslate">GameMaker Studio 2</span>碰撞</a></li></ul><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down5" href="#">纹理交换和顶点批处理</a></p><div class="droptext" data-targetname="drop-down5"><p class="dropspot">如果打开<a href="../GameMaker_Language/GML_Reference/Debugging/show_debug_overlay.htm"><strong>调试覆盖图</strong></a>，则在测试时，屏幕顶部的括号中将显示两个数字。第一个是<strong>完成的纹理交换</strong>数量，第二个是<strong>顶点批处理</strong>数量。许多因素都会影响这些数字，并且您永远都不会将它们降低到（0）（0），因为发动机每一步都需要一个或两个，但是您应该力求将这些值降低得尽可能低。</p><p class="dropspot"><img alt="The Debug Overlay Bar" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractices_DebugOverlay.png" />对于纹理交换，最好的和最有效的方法是优化精灵和背景在纹理页面上的存储方式。这是通过<a href="../The_Asset_Editors/Sprites.htm">sprite属性</a>完成的，您可以在“<a href="../Settings/Texture_Groups.htm">纹理组编辑器”中</a>创建纹理页面。如果您有一些仅在主菜单中使用的图像（例如），则将它们放到单独的<a href="../Settings/Texture_Information/Texture_Pages.htm">纹理页面上</a>。如果您具有特定级别的图像，或者玩家和敌人等，则相同。基本上，您希望通过使用对它们进行分组，以便尽可能减少交换。此外，为了帮助使<a class="glossterm" data-glossterm="虚拟RAM" href="#">VRAM</a>保持最佳状态，您可以根据需要使用不同的<a href="../GameMaker_Language/GML_Reference/Drawing/Textures/Textures.htm">预取和刷新</a>功能从内存中加载和删除纹理。</p><p class="note"><strong>注意</strong>：如本页面开头所述，如果您的游戏运行良好且FPS不错，则不必过多担心纹理交换...尤其是在桌面目标上创建项目时。这些优化最适合用于大型游戏或在低端移动设备上使用，如果使用不当，可能会对性能产生负面影响。</p><p class="dropspot">顶点信息以“批次”的形式发送到GPU进行绘图，通常批次越大越好。因此，在绘制时应避免“破坏”批处理，因为这会增加发送到GPU的顶点批处理的数量。有很多事情会破坏批处理，主要是<strong>混合模式</strong>，设置<strong>绘制颜色</strong>，设置<strong>绘制alpha</strong>以及使用内置形状和基元进行绘制。</p><p class="dropspot">因此，如果您有许多使用 <span class="inline">bm_add</span>例如，混合模式-您将为每个模型创建一个新的顶点批处理，这绝对是一件坏事！相反，在游戏中有一个控制器对象，它可以绘制所有项目符号，如下所示：</p><p class="code">gpu_set_blendmode(bm_add);<br/> with (obj_BULLET)<br/>     {<br/>     draw_self();<br/>     }<br/> gpu_set_blendmode(bm_normal);
    </p><p class="note"><strong>注意</strong>：这不仅仅适用于使用<span class="inline" style="font-size: 14px">bm_add</span> －任何混合更改都会破坏批处理并带来性能上的损失。</p><p class="dropspot">这样，所有子弹将在同一批次中绘制。该方法也可以应用于alpha并绘制颜色，并且实际上可以明智地使用函数<a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendenable.htm"><span class="inline">gpu_set_blendenable()</span></a> ， <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestref.htm"><span class="inline">gpu_set_alphatestref()</span></a> ， 和<a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestenable.htm"><span class="inline">gpu_set_alphatestenable()</span></a>尽管它们可能并不适合所有类型的图形或项目，但它们可以极大地提高性能，并且可以在整个项目代码中根据需要启用/禁用它们。</p><p class="note"><strong>注意</strong>：如果您不需要使用控制器以这种方式绘制实例，则可以在Draw Event中添加注释以抑制默认绘制，或使实例不可见（尽管这样做会阻止所有代码运行）对于所有draw事件中的实例）。</p><p class="dropspot">减少这些数量的另一种方法是，除非绝对必要，否则<strong>禁用sprite的“单独的纹理页面”选项。</strong>以这种方式存储的每个图像将发送到其自己的纹理页面并以不同的方式进行批处理，因此将这些图像放置在常规纹理页面上会更好。然后，您可以使用<a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a>函数并将其存储在变量中以供以后使用。这可能是少量的额外代码，但是您将获得的提升是值得的。请注意，此方法将不允许纹理重复！</p><p class="dropspot">与所有这些技巧一样，如果它使您的生活更难以改变并且您的游戏运行良好，请不要担心太多...</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#">粒子</a></p><div class="droptext" data-targetname="drop-down6"><p class="dropspot"><a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">粒子</a>提供了一种非常快速有效的方式来在游戏中创建动态效果，并且总体而言它们具有良好的性能。但是，值得注意的是，在粒子上使用添加混合，alpha混合和颜色混合可能会降低性能，尤其是在移动目标上，因此，如果不需要，请不要使用它！特别地，添加混合可以极大地增加顶点批次，应谨慎使用。</p><p class="dropspot">请注意，在非WebGL HTML5目标上，具有多色，褪色的粒子将需要大量图像缓存，并且速度非常慢。但是，由于可以对粒子精灵进行动画处理，因此您可以创建具有子图像的动画精灵，这些子图像会更改颜色，然后将其用于粒子。它看起来仍然像是逐渐的颜色变化，但不需要不断创建缓存图像。</p><p class="dropspot"><a href="Guide_To_Using_Particles.htm">您可以从“粒子使用指南</a>”页面中找到有关粒子的更多信息。</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#">表面</a></p><div class="droptext" data-targetname="drop-down7"><p class="dropspot">最后，我们将简要介绍一下<a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">曲面的</a>使用，因为<span class="notranslate">GameMaker Studio 2</span>在游戏中使用曲面时具有相当重要的优化：可以打开和关闭<strong>深度缓冲区</strong>。</p><p class="dropspot">当您仅按常规使用曲面时，GMS2实际上会创建一个曲面和一个随附的深度缓冲区，以确保在3D绘制任何内容时进行正确的深度排序。但是，对于大多数2D游戏而言，不需要额外的深度缓冲区，因此会占用额外的内存空间和处理时间，而这些时间和空间可能用于其他用途。这是功能<a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm"><span class="inline">surface_depth_disable()</span></a>发挥作用...</p><p class="dropspot">可以在创建曲面以禁用深度缓冲区生成之前调用此函数，并且此后创建的所有曲面都不会为其创建深度缓冲区。您可以根据需要启用/禁用此功能，甚至可以在游戏开始时调用一次以禁用所有后续表面调用的深度缓冲区（在大多数2D游戏中都可以）。它不会显着提高性能，但是如果您的游戏严重依赖表面并且可能会阻止您的游戏在低规格设备上耗尽内存，那么肯定要牢记这一点。</p></div><p></p><p>除了上面提到的主要内容外，还有其他一些更通用的内容可以帮助提高性能，并且也被视为“良好实践”：</p><ul class="colour"><li>不要害怕使用三角函数，因为（与流行的看法相反）它们非常快，特别是与粒子，碰撞，弦等相比时。</li><li>不要在Draw事件中放置非用于绘制事物的代码</li><li>使用警报来调用不必在每一步都被调用的任何代码（而不是将其始终添加到Step事件中）</li></ul><p>但是，正如我们在页面开头提到的那样，所有这些优化都是可选的，并且如果您的游戏运行良好（有60个顶点批处理，80个纹理交换，添加剂混合等），那么不必担心太多！在编写下一个游戏时，请记住这些事情... </p><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">返回：<a href="Additional_Information.htm">其他信息</a></div><div style="float:right">下一页：<a href="The_File_System.htm">文件系统</a></div></div></div><h5><span data-keyref="Copyright Notice">©版权所有<span class="notranslate">YoYo Games Ltd.</span> 2021保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
Nest Practices
-->
  <!-- TAGS
best_practices
-->
</body>
</html>