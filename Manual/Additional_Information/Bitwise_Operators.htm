<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>按位运算符</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="解释按位运算符如何工作的页面" />
  <meta name="rh-index-keywords" content="按位运算符" />
  <meta name="search-keywords" content="按位,按位运算符" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>按位运算符和二进制</h1><p>在计算机时代的开始，<strong>二进制</strong>和<strong>十六进制</strong>（十六进制）是一种生活方式，这可能是因为高级语言（例如BASIC）运行太慢了。例如，乘以32 x 32可能需要花费多个CPU周期才能使用BASIC，但是对于二进制，它是在单个CPU周期中作为单个操作完成的。</p><p>但是，如今，即使是基本PC的强大功能，您也不必再为此担心，您可以“漫长的路途”做事，因为计算机的速度及其更复杂的CPU构造将弥补任何不足。这种方法具有的优点。这当然是个好消息，因为这意味着您不必再优化编写的每一行代码，但是如果是这种情况，那么您真的应该真正关心二进制吗？</p><p>答案肯定是“是的，你应该”。的确，您仍然可以提高速度-有时这些速度可能很重要-使用二进制和十六进制可以更好地了解CPU的运行方式，还可以导致编写更好的代码，能够更好地打包数据并一些任务要简单得多。此页面将解释什么是二进制文件以及在制作游戏时如何使用它。</p><p>因此，让我们首先看一下最基本的二进制理论-数字是如何产生的。看一下这张桌子：</p><p class="code">000 = 0<br/> 001 = 1<br/> 010 = 2<br/> 100 = 4</p><p>每个1或0代表一个<a class="glossterm" data-glossterm="少量" href="#">数据位</a>，正如您所看到的，这意味着在二进制中10等于2！每个比特的2倍与第一比特等于1，因此，位2 = 2，以前的值位3 = 4，位4 = 8等（如本示于下<a class="glossterm" data-glossterm="字节" href="#">字节</a>表）：</p><p class="code">00000001 = 1<br/> 00000010 = 2<br/> 00000100 = 4<br/> 00001000 = 8<br/> 00010000 = 16<br/> 00100000 = 32<br/> 01000000 = 64<br/> 10000000 = 128</p><p>如果您希望数字是2的幂，那很好，但是我们如何创建更复杂的数字呢？那么单个二进制数只能存储0或1，就是这样，因此对于更复杂的数字，我们需要将位加在一起。例如，如果我们想制作6，则可以像这样将4和2加在一起。</p><p class="code">00000010 = 2<br/> 00000100 = 4<br/> 00000110 = 6</p><p><strong>所有</strong>二进制数字以及计算机内部如何构成任何数字都是如此。让我们以一个稍微复杂一些的数字作为进一步的示例：23.数字23实际上是由 <span class="inline">1+2+4+16</span>或者 <span class="inline">00010111</span>。还有一个更复杂的示例：196吗？好吧，那是从 <span class="inline">128+64+4</span>或者 <span class="inline">11000100</span>。因此，实际上并不是那么复杂！</p><p>但是，如果我们开始执行超出字节范围（可以存储0到255之间的数字）范围的值，那么它的确开始变得更难追踪。例如，217,361是 <span class="inline">110101000100010001</span>以二进制形式。或者， <span class="inline">1+16+256+etc...</span>无论所表示的值是什么，规则都是相同的-每个数字都是通过将多个位加在一起而创建的。</p><p>现在，我们如何对这些值执行数学运算？假设您要存储 <span class="inline">true</span>或者 <span class="inline">false</span>作为价值。通常，编译器会使用 <span class="inline">INT</span>（一个<span
      class="inline">INT</span>通常被定义为一个有符号的32位数字-带符号只是意味着它可以是正值或负值，而无符号则意味着它只能是正值），然后简单地将其分配给 <span class="inline">0</span>或者 <span class="inline">1</span>。只有2个州， <span class="inline">true</span> / <span class="inline">false</span>值是理想的存储方式，如果执行此操作，则可以存储32 <span class="inline">true</span> / <span class="inline">false</span>每个位 <span class="inline">INT</span>而不是一个，因为 <span class="inline">INT</span>由32位组成。</p><p>我们将如何做呢？事实证明，很容易：</p><p class="code">flags = flags | 1;</p><p>这 ”<span class="inline">|</span> “运算符是按位的 <span class="inline">OR</span>，这意味着上面的说明 <span class="inline">ORs</span>1放入变量中保存的值 <span class="inline">flags</span>。如果您记得较早，则使用1将设置第一位。如果我们想设置第二个位，我们可以这样做：</p><p class="code">flags = flags | 2;</p><p>我们 <span class="inline">OR</span>2，因为位模式 <span class="inline">00000010</span>等于2。那么二进制到底是什么 <span class="inline">OR</span>接线员呢？好吧，它将所有位合并到一个值中，如下所示：</p><p class="code">010110100 // Value 1<br/> 110011001 // value 2<br/> 110111101 // Value 1 OR Value 2</p><p>这是OR运算符<a class="glossterm" data-glossterm="真值表" href="#">的真值表：</a></p><p class="code">00 | 00 = 00<br/> 00 | 01 = 01<br/> 01 | 01 = 01<br/> 01 | 00 = 01</p><p>因此，如果存在一个带有2个零的值，它将保持为零。使用像这样的位的优势 <span class="inline">true</span>/<span class="inline">false</span>状态，就是您可以在一次操作中将几位设置为“标志”，而普通布尔值根本无法做到这一点。例如，假设第1位是“活动”标志，而第3位是“可见”标志。我们可以通过以下两种方法进行设置：</p><p class="code">flags = flags | 5<span class="inline"></span>;</p><p>这是因为5是 <span class="inline">00000101</span>以二进制形式，并遵循上述规则，变量“ flags”将把这两个位与自己的位合并。因此，即使已经设置了位1，该操作仍然有效，并且现在也将设置位3。</p><p>清除标志呢？好吧，这就是按位排列的“<span class="inline">&amp;</span> ”<span class="inline">AND</span>操作进来。当你 <span class="inline">AND</span>某些情况下，保留在掩码中设置的位，而删除在掩码中清除的位-像这样：</p><p class="code">01110010101 // Value 1<br/> 00110000100 // Value 2<br/> 00110000100 // Value 1 AND value 2</p><p>如您所见，在每个值中都有1的情况下，将保留1，在其中有混合或0和1的情况下，这些值将重置为0。这是用于 <span class="inline">AND</span>ing：</p><p class="code">00 &amp; 00 = 00<br/> 01 &amp; 00 = 00<br/> 00 &amp; 01 = 00<br/> 01 &amp; 01 = 01</p><p>因此，只有在每个地方都有一点点时，它才会被保留。这意味着，就像您可以一次设置多个标志一样，您也可以一次清除多个标志。例如，让我们以上面的情况为例，但是这次清除它们。我们想要清除位1和3（为我们提供值5），但是要记住上面的真值表，我们要做的就是保留所有其他位，并清除位1和3。这将是一个二进制“掩码” “ 11111111111111111111111111111010”（32位）。该掩码保留当前设置的所有位，但清除我们实际要清除的两个位。因此，如果值为1000111011，并且我想使用上面的掩码清除位1和3，则最终结果如下：</p><p class="code">00000000000000000000001000111011 // Value<br/> 11111111111111111111111111111010 // Mask<br/> 00000000000000000000001000111010 // Value AND Mask</p><p>很好，但是如果每次必须清除标志时都必须解决此问题，那么它将变得很累。我们需要的是一种轻松翻转位的方法（最好没有CPU开销）。幸运的是，通过使用“ <span class="inline">~</span> ” <span class="inline">NOT</span>操作员。</p><p>这 <span class="inline">NOT</span>运算符就是它所说的，<em>而不是</em>那些位。这是一个事实表 <span class="inline">NOT</span>。</p><p class="code">~00 = 11<br/> ~01 = 10<br/> ~10 = 01<br/> ~11 = 00</p><p>该运算符使删除标志变得非常简单，并且更好的是，它通常是编译时优化，这意味着如果您使用的是常数（即不是变量），则编译器将自动为您翻转位。将此语句用作我们要再次清除位1和3的位置：</p><p class="code">a = a &amp; ~5;</p><p>这实际上将编译为“<span class="inline">a &amp; 11111111111111111111111111111010</span> “。这使得清除旗标的生活变得非常简单。</p><p>我们要查看的最后一个运算符是“<span class="inline">^</span> ” <span class="inline">EOR</span> （<span class="inline">Exclusive OR</span> ，有时称为 <span class="inline">XOR</span>），此运算符会将两个值中设置的位翻转。这是 <span class="inline">EOR</span>真值表：</p><p class="code">0 ^ 0 = 0<br/> 0 ^ 1 = 1<br/> 1 ^ 0 = 1<br/> 1 ^ 1 = 0</p><p>这是一个奇怪的问题，但非常有用。例如，假设我们想要一个简单地从0到1再回到0（在0和1之间切换）的计数器，我们可以加一个并做一个 <span class="inline">IF</span>看看是否达到2，然后将其重置为1。或者...我们可以加1，然后 <span class="inline">AND</span>1 <span class="inline">01+01 = 10</span> ， 和 <span class="inline">10 &amp; 01 = 0</span>），或者我们可以这样做：</p><p class="code">a = a ^ 1;</p><p>第一次运行时它的作用是 <span class="inline">0 ^ 1 = 1</span>，然后第二次 <span class="inline">1 ^ 1 = 0</span>，从而使事物从0到1来回切换。</p><p>所以 - <span class="inline">OR</span> （<span class="inline">|</span> ）， <span class="inline">AND</span> （<span class="inline">&amp;</span> ）， <span class="inline">NOT</span> （<span class="inline">~</span> ） 和 <span class="inline">EOR</span>（<span class="inline">^</span> ）让我们相对容易地操作位，从而允许我们在最简单的级别一次控制多个位。很明显，在开发游戏时，我们可以将这些操作用于其他用途，例如掩盖精灵，进行整数 <span class="inline">MOD</span>操作（使用 <span class="inline">AND</span>）或执行不错的循环计数器。</p><p>因此，我们可以简单地进行按位运算，但是让我们看一下更复杂的东西，首先要问的是，计算机如何添加？让我们看一个非常简单的例子： <span class="inline">1+1</span> 。</p><p class="code">00000001<br/> 00000001
    <br/> 00000010
  </p><p>就像普通的加法一样，我们将数字加在一起，然后溢出到下一列，但是与普通的十进制加法不同，我们只能从0到1，而不能从0到9。 <span class="inline">1+1</span>意味着我们溢出到 <span class="inline">10</span>。因此，让我们看一个更复杂的示例。</p><p class="code">01011011 = 91<br/> 00101101 = 45<br/> 10001000 = 136</p><p>显然在这里很难看到，但是溢出会一直持续下去，直到一列中没有任何溢出为止。值得注意的是，计算机一次只能相加（或相减，相乘或相除）2个数字。拿 <span class="inline">19 + 19 + 19</span>。作为人类，我们可以将所有的9加在一起，携带2，然后继续！但是计算机无法做到这一点-他们可以做到的是：<span class="inline"> (19 + 19) + 19</span> 。因此，他们将以2为单位进行每次计算。</p><p>作为程序员，我们最感兴趣的二进制计算是乘法和除法。计算机只乘以2s，要执行更多操作，它会将数字分开，然后将所有结果相加。首先让我们举一些非常简单的例子。 <span class="inline">4 * 2 = 8</span> 。现在将二进制乘以2，我们<em>将</em>LEFT的所有位都移位1。像这样：</p><p class="code">00000100 * 2 = 00001000 = 8</p><p>在这种情况下，所有位都向左移动一位，从而使其从第3位移动到第4位，并将值从4更改为8。</p><p class="code">101 = 01100101 * 2 = 11001010 = 202</p><p>同样，所有位都移动一个，然后乘以2。那么，乘以4怎么办？容易，我们将所有内容左移2，而不是一。那么16或128呢？这将需要分别左移4位或7位。这非常有用。这意味着我们可以通过简单地移动位来进行简单的乘法。为此，我们使用<strong>左移</strong>运算符 <span class="inline">&lt;&lt;</span>。这里有些例子：</p><p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br/> 00000001 &lt;&lt; 2 = 000000100 = 4<br/> 00000001 &lt;&lt; 3 = 000001000 = 8<br/> 00000001 &lt;&lt; 4 = 000010000 = 16<br/> 00000001 &lt;&lt; 5 = 000100000 = 32<br/> 00000001 &lt;&lt; 6 = 001000000 = 64<br/>    00000001 &lt;&lt; 7 = 010000000 = 128<br/> 00000001 &lt;&lt; 8 = 100000000 = 256</p><p>现在，除了对快速/简单乘法非常有用之外，它对于设置特定位也非常有用，而无需找出位值。假设我们要设置第27位，那是几号？ （顺便说一下，是67108864！），那么我们可以使用上面的语法轻松地设置如下标记：</p><p class="code">a = a | (1 &lt;&lt; 27)</p><p>好的...所以实际上这将是到目前为止我们描述事物的方式的第26位（因为位从1开始），但实际上...位从0开始，然后向上而不是从1开始因此，尽管INTEGER中有32位，但位的范围是0到31，而不是1到32。这实际上非常有用，因为我们现在可以为位号设置常量。</p><p>因此，假设第27位是活动标志，而第0位是爆炸标志。我们如何设置两者？</p><p class="code">ACTIVE = 27;<br/> BOOM = 0;<br/> A = A | (1 &lt;&lt; ACTIVE) | (1 &lt;&lt; BOOM);</p><p>这看起来像很多代码，但是如果这些数字是常量，则编译器会将这些操作预编译为单个值，这样我们最终将其作为实际代码。</p><p class="code">A = A | 13421772;</p><p>清除这些位（如上所述）仅是使用NOT修饰符的问题，如下所示：</p><p class="code">A = A &amp; ~((1 &lt;&lt; ACTIVE) | (1 &lt;&lt; BOOM));</p><p>因此，这很高兴使我们可以设置和清除所需的任何位，还可以使我们大规模压缩数据结构。压缩数据结构是一件好事，因为如果使用更少的内存，则会减少缓存未命中的次数，并且代码的运行速度也会更快。这样说，复制32Mb或数据或4Mb更快？好吧，很明显4是。因此，如果您可以将所有标志打包到一个内存访问中，那就太好了！</p><p>现在，让我们快速看一下如何进行除法，以及除法为何如此有用。通过使用<strong>右移</strong>运算符将位<em>右移来完成除法</em> <span class="inline">&gt;&gt;</span>。让我们以一个简单的数字-64-除以32：</p><p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010</p><p>因此，您将一位向下移位5位（这是32位所需的移位数–如上所示），即为2。但是，如果这里还有其他位，会发生什么呢？好吧，让我们看一下：</p><p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010</p><p>所以你去了...。完全一样。我们向下移动的位丢失了。这实际上是非常有用的，因为当我们需要剩余部分时，有一种更简单的方法来获取它，稍后我们将介绍。但首先，让我们举一个实际的例子。我有一个X和Y位置，我想获得它所在的网格单元，其中网格的大小为32x32。这种方法允许存储对象，碰撞，标志–各种事物，并非常快速地访问它们。所以我们开始：</p><p class="code">var X_index = x &gt;&gt; 5;<br/> var Y_index = y &gt;&gt; 5;<br/> cell_data = mygrid[# X_index,Y_index];</p><p>那么，如果我们想要剩余的东西怎么办？可能将此剩余部分用作某种顺序标记或某种标记。不管原因是什么，获得余数就像做一个 <span class="inline">AND</span>：</p><p class="code">var remainder = x &amp; 31<br/> var X_Index = x &gt;&gt; 5;</p><p>现在，您可能已经注意到我们在这里使用了多行代码（通常是这样），但这仍然只是几个非常快速的指令。但是为什么要31？好吧，因为第5位是32，所以下面的所有位都是31，这是最大余数，所以我们 <span class="inline">AND</span>与（我们也可以使用 <span class="inline">(1 &lt;&lt; 5) - 1</span>这将使 <span class="inline">32 - 1 = 31</span>）。现在，如果我在不了解二进制文件的情况下执行此操作，则将如下所示：</p><p class="code">var r = x mod 32;<br/> var X_Index = floor(x / 32);</p><p>那么，为什么情况会更糟呢？好吧，为了除以32，我们必须执行一个浮点除法-这显然需要时间，但是为了执行 <span class="inline">mod 32</span>，您实际上必须再做一个！如果我们在汇编器中执行此操作，则实际上我们将BOTH值一分为二，但是您不会在高级语言中获得此值（嗯……不是很经常），因此您必须将所有工作重复两次。这加起来，尤其是如果您要进行大量这样的紧密循环计算时。如上所示，使用位移位进行整数除法确实有助于优化游戏。</p><p>由于要理解并应用于现实世界的编程环境可能是一个非常复杂的概念，因此您可以在下面找到一系列简短的示例，这些示例可以应用于使用<span class="notranslate">GameMaker Studio 2</span>制作的任何游戏。</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">瓷砖对齐</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot"><span class="notranslate">GameMaker Studio 2</span>开发人员经常使用该功能 <span class="inline">place_free()</span>，然后在发现碰撞时，尝试通过在 <span class="inline">x</span>或者 <span class="inline">y</span>位置，同时继续执行该功能，或使用 <span class="inline">move_outside_all()</span>功能。</p><p class="dropspot">那么，什么是更快的方法呢？好吧，如果我们使用适当的2次幂瓦片，那么我们就有一种非常简单的方法，而且闪电般快速。如果我们向右移动，并且已经移入碰撞块，那么我们知道一切都对准了32，因此我们还需要将精灵对齐到32像素边界（最好是向左对齐），因此精灵被移出碰撞。这很容易，知道我们上面使用的规则来获取余数，并且知道如何获得位的倒数，我们可以简单地做到这一点：<br/></p><p class="code">x = x &amp; ~31;</p><p class="dropspot">没错，这就是对齐32像素边界所需的全部。通过更改31，我们可以对齐任何所需的数字-只要它是2的幂（这等于除以32，然后乘以32，从而除去低位）。</p><p class="dropspot">如果我们想向右对齐，则可以执行上面的操作，但是要加上32以将其移至下一个图块。简单的。所有这些使整个冲突代码的运行速度大大加快，并使您可以将CPU时间花费在真正需要它的地方。</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">钥匙和门</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot">假设您有一个带有几个门的关卡，每个门都有一个钥匙。如何轻松标记特定门的钥匙？好吧，通常您只需为钥匙和门分配一个ID。那么，如果您想要一把钥匙打开2或3个门怎么办？简单。您使用掩码。门将被分配一个单一的位，如下所示：<br/><br/></p><p class="code">door_id = 1; // 0001<br/></p><p class="dropspot">其他的将是这样的：<br/><br/></p><p class="code">door_id=2; // 0010<br/>door_id=4; // 0100<br/>door_id=8; // 1000<br/>etc...<br/></p><p class="dropspot">如果我们想要钥匙打开门1和3，那么钥匙的MASK值将为5（二进制值为101）。如果我们执行 <span class="inline">AND</span>得出“不为零”的信息，那么我们知道钥匙可以打开门。您还可以通过将MASK设置为0来使键没有打开。有关实际检查，请参见下面的代码：</p><p class="code">if ((key_id &amp; door_id) ! = 0)<br/>    {<br/>    opendoor();<br/>    }<br/></p><p class="dropspot"><br/></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">循环计数器</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot">假设我们要一个简单的动画计数器，从0到15（因为我们有16帧动画）。通常，您会做一个增量，然后做一个 <span class="inline">if</span>检查以包装数字，但在此示例中，我们使用<tt><span class="notranslate">AND(&amp;)</span></tt>运算符：</p><p class="code">counter = (counter + 1) &amp; 15;</p><p class="dropspot">由于16是2的幂，因此我们可以将该数字减1并将其用作掩码，然后可以使用该掩码包装计数器值。如果计数器从15上升到16，我们最终得到位模式 <span class="inline">10000</span>，如果我们 <span class="inline">AND</span>15（位模式） <span class="inline">01111</span> ），我们最终得到<tt><span class="notranslate">00000</span></tt> （简单地为零）。这意味着上述代码可用于包装2的幂范围内的值。</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">2检验的力量</a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot">如果您想查看某物是否为2的幂，该怎么办？好吧，这是一个巧妙的小把戏..这将返回 <span class="inline">true</span>如果给定值是2的幂：<br/></p><p class="code">function is_pow2(_val)<br/>    {<br/>    return _val &amp; (_val - 1)) == 0;<br/>    }</p><p class="dropspot">因此，如果我们有数字51（<span class="inline">110011</span> ）这是做什么用的？好吧，我们得到这个... <span class="inline">110011 &amp; 110010</span> ，这显然使我们 <span class="inline">false</span>，因为在 <span class="inline">AND</span>。如果我们有64（<span class="inline">1000000</span> ），那么它就变成了... <span class="inline">1000000 &amp; 0111111</span><em>确实</em>让我们为0，所以 <span class="inline">true</span>。</p><p class="dropspot"><br/></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">索引对齐</a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot">这是一些快速代码，可与2的幂次对齐。 （1、2、4、8、16等）。这对于内存分配或确保将数据写入适当的边界非常有用。在这个例子中 <span class="inline">_val1</span>需要与 <span class="inline">_val2</span>字节，其中 <span class="inline">_val2</span>是2的幂。这个小功能将四舍五入到所需数字的下一个边界。<br/></p><p class="code">function align_pow2(_val1, _val2)<br/>    {<br/>    return _val1 + (_val2 - 1)) &amp; ~(_val2 - 1);<br/>    }<br/></p><p class="dropspot"><br/></p><p class="dropspot"><br/></p></div><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">返回：<a href="Additional_Information.htm">其他信息</a></div><div style="float:right">下一页：<a href="Type_Tables.htm">类型表</a></div></div></div><h5><span data-keyref="Copyright Notice">©版权所有<span class="notranslate">YoYo Games Ltd.</span> 2021保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
Bitwise Operators
-->
  <!-- TAGS
bitwise_operators
-->
</body>
</html>