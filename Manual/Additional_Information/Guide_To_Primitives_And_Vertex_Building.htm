<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>原始体和顶点构建指南</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="解释如何设置和使用图元和顶点缓冲区的页面" />
  <meta name="rh-index-keywords" content="原始体和顶点构建指南" />
  <meta name="search-keywords" content="原始建筑,原语,顶点,顶点缓冲区,顶点格式" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>原始体和顶点构建指南</h1><p>本指南简要介绍了如何使用自定义<strong>顶点格式</strong>和<strong>顶点缓冲区</strong> <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">来构建和使用图元</a>。</p><p>通常，当您开始使用3D，特殊效果，复杂的绘制过程或<span class="notranslate">shaders</span>您不必担心所使用的顶点格式，因为<span class="notranslate">GameMaker Studio 2</span>会自动为您设置并传递<a class="glossterm"
      data-glossterm="顶点" href="#">顶点数据。</a>但是，有时需要创建自己的顶点数据并对其进行格式化以适应需要，特别是在您需要提高速度或希望传递更多信息时。例如，标准顶点格式包括x，y，z 3D位置，颜色（带有Alpha）和UV纹理坐标，如果您自己创建，则其外观应类似于：</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_textcoord();
    <br/> my_format = vertex_format_end();</p><p>但是，如果仅使用（例如） <span class="notranslate">shader</span>来操纵顶点的位置，则无需传递颜色或纹理数据。在这种情况下，您可以这样创建自己的格式：</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> my_format = vertex_format_end();</p><p>定义顶点格式时，总共可以使用五个不同的顶点属性：</p><ul class="colour"><li>颜色</li><li>普通的</li><li>位置</li><li>3D位置</li><li>纹理坐标</li></ul><p>通常，您必须<em>始终</em>将位置或3D位置作为格式的一部分提供，但所有其他位置都是可选的。</p><p>您应该注意，一旦创建了顶点格式，在构建<strong>图元</strong><i>时必须遵循</i>定义顶点属性的顺序。因此，如果已将顶点格式定义为位置，颜色和纹理坐标，则<b><i>必须</i>以相同顺序将这些属性添加到图元，否则会出错</b>。还要注意，与任何其他动态资源一样，顶点格式也需要内存，因此在不需要此功能时应将其删除。 <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_delete.htm"><tt>vertex_format_delete()</tt></a> 。</p><p>您构建的所有图元都保存在<b>顶点缓冲区中</b>。必须事先创建它，然后由用于构建基本体的函数引用。可以根据需要重复使用顶点缓冲区多次，以创建不同的图元，或者可以“冻结”该顶点缓冲区以在游戏或关卡期间维持特定的图元类型（这是最快的方法，因此，如果您知道（如果您构建的原语不会更改，那么您应该始终使用此选项）。</p><p>以下代码显示了构建单个三角形图元的示例：</p><p class="code">// CREATE EVENT<br/> v_buff = vertex_create_buffer();<br/> vertex_begin(v_buff, global.my_format);<br/> vertex_position(v_buff, 10, 10);<br/> vertex_colour(v_buff, c_white, 1);<br/> vertex_texcoord(v_buff, 0, 0);<br/> vertex_position(v_buff, 110, 10);<br/>    vertex_colour(v_buff, c_white, 1);<br/> vertex_texcoord(v_buff, 1, 0);<br/> vertex_position(v_buff, 110, 110);<br/> vertex_colour(v_buff, c_white, 1);<br/> vertex_texcoord(v_buff, 1, 1);<br/> vertex_end(v_buff);
    <br/>
    <br/> // DRAW EVENT<br/> var tex = sprite_get_texture(spr_Background, 0);<br/> shader_set(shd_shimmer);
    <br/> vertex_submit(v_buff, pr_trianglelist, tex);<br/> shader_reset();
  </p><p>在这里，我们首先在实例的Create Event中创建顶点缓冲区，然后开始定义构成三角形图元的不同顶点，并给出三个点中每个点的位置，颜色和纹理UV坐标我们要使用的。然后，我们结束顶点定义，并且知道具有该顶点数据的顶点缓冲区存储在变量“ v_buff”中。</p><p class="note"><strong>注意</strong>：如果要不断更新缓冲区的内容，则将在给定顶点数据的情况下创建缓冲区，然后在绘制完缓冲区之后再次销毁该缓冲区，所有操作均在同一步骤中进行。</p><p> <span class="notranslate">shader</span>在Draw Event中绘制顶点缓冲区的内容。这是一个非常简单的示例，基本上就是<span class="notranslate">GameMaker Studio 2</span>在内部的工作方式，即：当绘制一个精灵时， <span class="notranslate">GameMaker</span>创建一个顶点缓冲区，其中包含四个顶点的顶点将创建两个三角形（它们组成一个正方形，也称为“四边形”），并使用子画面图像对这两个三角形进行纹理处理。绘制此子画面时，将提交顶点缓冲区，并将其内容绘制到屏幕上。</p><p>您会注意到，当我们提交绘制的顶点缓冲区时，我们会提供基本类型。您使用的图元类型可以是点，线列表或条带，或三角形列表或条带，但由于大多数移动硬件都不接受该图元类型，<i>因此不允许使用三角形扇形。</i>不要忘记为将用于绘制图元的图元类型正确设置顶点缓冲区的格式。例如，将两个三角形图元绘制为三角形列表需要6个点，但是作为三角形带，则只需要4个点。您使用哪种类型取决于您，并且将取决于您要绘制的内容以及要实现的效果。</p><p>当以这种方式使用自己的顶点缓冲区时，需要注意的最后一个重要点是，它如何影响发送到GPU的顶点批处理。创建顶点缓冲区时，将创建最低级别的图形数据，因此绘制所有内容时， <span class="notranslate">GameMaker Studio 2</span>会将缓冲区直接发送到图形卡。因此，如果要进行更好的批处理，则必须自己进行处理，并将要批处理的内容存储在同一缓冲区中。</p><p>如前所述，顶点格式是通过以下5种属性类型（通过适当添加 <tt>vertex_format_add_*</tt>功能）：</p><ul class="colour"><li>颜色</li><li>普通的</li><li>位置</li><li>3D位置</li><li>纹理坐标</li></ul><p>在GLSL ES <span class="notranslate">shader</span> ，可以使用以下4个属性来识别这些种类：</p><ul class="colour"><li>颜色</li><li>普通的</li><li>位置</li><li>纹理坐标</li></ul><p>现在，这看起来似乎很奇怪，因为我们似乎可以在顶点格式中指定比在顶点<span class="notranslate">shader</span>更多的属性种类。但是，在<span class="notranslate">shader</span><i>位置”</i>和“ <i>3D位置”</i>被视为<em>相同的</em>属性，只是<i>期望“位置</i>”仅具有“ x”和“ y”坐标，而“ <i>3D位置”</i>具有“ x”，“ y”和“ z”坐标。那么，如何将顶点格式的内容映射到<span class="notranslate">shader</span>属性定义方式？ <span class="notranslate">shader</span>开始看一组典型的属性：</p><p></p><p class="code">attribute vec3 in_Position;        // (x,y,z)<br/> //attribute vec3 in_Normal;        // (x,y,z) unused in this shader.<br/> attribute vec4 in_Colour;          // (r,g,b,a)<br/> attribute vec2 in_TextureCoord;    // (u,v)</p><p>这是一段代码，用于设置与此<span class="notranslate">shader</span>兼容的顶点格式：</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_textcoord();
    <br/> my_format = vertex_format_end();</p><p>现在， <span class="notranslate">shader</span>属性如何与顶点格式类型匹配？它只是基于命名约定：</p><ul class="colour"><li> “ in_Position”映射到 <tt>vertex_format_add_position / _3d()</tt></li><li><tt>&quot;in_Colour&quot; maps to <tt>vertex_format_add_colour()</tt></tt></li><li><tt><tt>&quot;in_TextureCoord&quot; maps to <tt>vertex_format_add_textcoord()</tt></tt>
      </tt></li></ul><p><tt><tt><tt></tt></tt>
    </tt>现在，当您具有相同种类的多个属性时，事情变得棘手，但是事情仍然基于相同的命名约定。现在，我们将讨论提供其他<b>颜色</b>和<b>纹理坐标</b>，因为<span class="notranslate">shader</span>或顶点格式中<b>只能有一个“</b>位置”和<b>一个“</b>法线”属性<em>，但是可以</em>有多个颜色或纹理属性。</p><p> <span class="notranslate">shader</span>添加其他颜色属性时<span class="notranslate">shader</span>属性的末尾添加一个数字，以指示该属性映射到顶点格式中的哪个特定条目。这是一个示例-首先是顶点格式：</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_textcoord();
    <br/> my_format = vertex_format_end();</p><p>现在，关联的<span class="notranslate">shader</span>属性为：</p><p class="code">attribute vec3 in_Position;      // (x,y,z)<br/> attribute vec4 in_Colour0;       // (r,g,b,a)<br/> attribute vec4 in_Colour1;       // (r,g,b,a)<br/> attribute vec2 in_TextureCoord;  // (u,v)</p><p>在这种情况下 <tt>in_Colour0</tt>映射到第一个 <tt>vertex_format_add_colour()</tt>和 <tt>in_Colour1</tt>映射到第二个。</p><p>纹理坐标的处理方式与颜色略有不同。基本上，任何不被称为 <tt>in_Position</tt>，<tt>in_Normal</tt>或其中之一 <tt>in_Colour[0 ... ]</tt>属性被视为纹理坐标。 <span class="notranslate">shader</span>的属性列表中，定义它们的顺序就是表示它们映射到的顶点格式中的哪个属性。请参见以下<span class="notranslate">GML</span>示例：</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_textcoord();
    <br/> vertex_format_add_textcoord();
    <br/> vertex_format_add_textcoord();
    <br/> my_format = vertex_format_end();</p><p> <span class="notranslate">shader</span>代码如下所示：</p><p class="code">attribute vec3 in_Position;      // (x,y,z)<br/> attribute vec4 in_Colour;        // (r,g,b,a)<br/> attribute vec2 in_myTexcoord;    // (u,v)<br/> attribute vec2 in_TextureCoord;  // (u,v)<br/> attribute vec2 in_Something;     // (u,v)</p><p>在这个例子中 <tt>in_myTexcoord</tt>，<tt>in_TextureCoord</tt>和 <tt>in_Something</tt>映射到以顶点格式定义的三个连续的纹理坐标属性。</p><p>您可以从以下页面找到创建顶点格式，顶点缓冲区和图元所需的所有功能的完整列表：</p><ul class="colour"><li> <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">基本体和顶点格式</a></li></ul><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">返回：<a href="Additional_Information.htm">其他信息</a></div><div style="float:right">下一页：<a href="Guide_To_Using_Blendmodes.htm">使用Blendmodes的指南</a></div></div></div><h5><span data-keyref="Copyright Notice">©版权所有<span class="notranslate">YoYo Games Ltd.</span> 2021保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
Primitive Building
Vertex Formats
Vertex Buffers
-->
  <!-- TAGS
using_primitives_vertex_buffers
-->
</body>
</html>