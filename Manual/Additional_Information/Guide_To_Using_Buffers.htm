<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>缓冲区使用指南</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="解释缓冲区如何工作的页面" />
  <meta name="rh-index-keywords" content="缓冲区使用指南" />
  <meta name="search-keywords" content="使用缓冲区,缓冲区" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>缓冲区使用指南</h1><p>缓冲区（在编程中）基本上是系统内存中的空间，用于存储几乎所有内容的小数据包（例如：数据传输，冲突，彩色数据等）。由于它保存在系统内存中，因此访问速度非常快，缓冲区通常用于非常短期的存储，例如在处理之前接收网络信息，或者在游戏中存储检查点（在示例在页面的下方给出）。</p><p><img alt="Buffer Memory" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Buffer_Memory.png" />缓冲区是通过在系统内存中分配以<a class="glossterm" data-glossterm="字节" href="#">字节</a><span
      class="glossextra">s</span>计算的空间创建的，只要您的游戏正在运行，或者直到使用适当的功能删除缓冲区（您可以找到所有<span class="notranslate">GML</span>缓冲区函数），该缓冲区才保留给您的游戏<a href="../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">此处</a>列出）。这意味着，即使您的游戏不清晰（例如，在移动设备上拨打电话时，游戏也会被置于后台），缓冲区仍将存在，但是如果关闭或重新启动游戏，缓冲区将丢失。</p><p class="note"><strong>注意</strong>：重新启动游戏不会清除或删除缓冲区！但这会阻止进一步访问以前创建的缓冲区，因为ID句柄将丢失，从而导致内存泄漏，最终导致游戏崩溃。因此，重新启动游戏时，请记住首先删除所有缓冲区。</p><p> <span class="notranslate">GameMaker Studio 2</span>允许创建四种不同的缓冲区类型。这样做的原因是，缓冲区被设计为高度优化的临时存储介质，因此，您应创建适合于您希望存储的数据类型的缓冲区，否则可能会出错或造成瓶颈在您的代码中。在进一步解释之前，让我们看一下四种可用的缓冲区类型（在<span class="notranslate">GML</span><strong>定义为常量</strong>）：</p><p></p><table><tbody><tr><th>持续的</th><th>描述</th></tr><tr><td><span class="notranslate"><span class="inline">buffer_fixed</span></span></td><td><br/>固定大小（以字节为单位）的缓冲区。该大小是在创建缓冲区时设置的，无法再次更改。</td></tr><tr><td><span class="notranslate"><span class="inline">buffer_grow</span></span></td><td><br/>缓冲区将<i>随着</i>添加数据而动态增长。您使用初始大小创建它（该大小应该是预期要存储的数据大小的近似值），然后它将扩展以接受更多溢出该初始大小的数据。</td></tr><tr><td><span class="notranslate"><span class="inline">buffer_wrap</span></span></td><td><br/>数据将<i>包裹的</i>缓冲区。当所添加的数据达到缓冲区大小的限制时，覆盖将被放回缓冲区的开头，并且从该点开始将继续写入。</td></tr><tr><td><span class="notranslate"><span class="inline">buffer_fast</span></span></td><td><br/>这是一个特殊的“向下精简”缓冲区，读取/写入速度非常快。但是它只能与 <span class="inline"><tt>buffer_u8</tt></span>数据类型，并且必须对齐1个字节。 （有关<b>数据类型</b>和<b>字节对齐的</b>信息，可以在此页面的下方找到）。</td></tr></tbody></table><p></p><p> <span class="notranslate">GameMaker Studio 2</span>时可用的缓冲区类型，而选择哪种缓冲区将很大程度上取决于您希望使用的缓冲区类型。例如，增长缓冲区将用于存储数据的“快照”以创建保存游戏，因为您不知道将要放置在其中的实际数据量，或者在您使用快速缓冲区时会使用知道您正在使用的值都在0到255或-128到127之间，例如在处理来自图像的<a
      class="glossterm" data-glossterm="RGB" href="#">ARGB数据时。</a></p><p><img alt="Buffer Types" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Buffer_Types.png" />创建缓冲区时，应始终尝试将其创建为适合该类型的大小，通常的规则是，应创建该缓冲区以容纳要存储的最大数据大小；如有疑问，使用增长缓冲区以防止覆盖错误。</p><p>创建缓冲区的实际代码如下所示：</p><p class="code">player_buffer = buffer_create(16384, buffer_fixed, 2);</p><p><br/>这将创建一个固定的缓冲区，长度为16384个字节，并且字节对齐为2，该函数返回一个唯一的ID值，该值存储在变量中，以供以后引用此缓冲区。</p><p>在将数据读取和写入缓冲区时，可以按其“数据类型”定义的数据“块”进行处理。 “数据类型”设置缓冲区中为写入的值分配的字节数，并且必须正确无误，否则您的代码会得到一些非常奇怪的结果（甚至是错误）。</p><p><strong>缓冲区按顺序</strong>写入（或从中读取），因为一个数据接一个地写入，每个数据都是固定类型的。这意味着理想情况下，您应该始终知道要向缓冲区写入哪些数据。这些数据类型在<span class="notranslate">GML</span>由以下常量定义：</p><p></p><table><tbody><tr><th>数据类型常量</th><th>字节数</th><th>描述</th></tr><tr><td><span class="inline">buffer_u8</span></td><td>1个</td><td><br/>一个无符号的8位整数。这是从0到255的正值。</td></tr><tr><td><span class="inline">buffer_s8</span></td><td> 1个</td><td><br/>有符号的8位整数。可以是-128到127之间的正值或负值（0被分类为正值）。</td></tr><tr><td><span class="inline">buffer_u16</span></td><td> 2</td><td><br/>一个无符号的16位整数。这是从0-65,535的正值。</td></tr><tr><td><span class="inline">buffer_s16</span></td><td> 2</td><td><br/>有符号的16位整数。可以是-32,768到32,767之间的正值或负值（0分类为正值）。</td></tr><tr><td><span class="inline">buffer_f16</span></td><td> 2</td><td><br/>一个16位浮点数。这可以是正值或负值，范围为+/-65504。 <b>（当前不支持！）</b></td></tr><tr><td><span class="inline">buffer_u32</span></td><td> 4</td><td><br/>一个无符号的32位整数。这是从0到4,294,967,295的正值。</td></tr><tr><td><span class="inline">buffer_s32</span></td><td> 4</td><td><br/>有符号的32位整数。这可以是正值或负值，范围是-2,147,483,648至2,147,483,647（0分类为正值）。</td></tr><tr><td><span class="inline">buffer_f32</span></td><td> 4</td><td><br/>一个32位浮点数。这可以是正值或负值，范围为+/- 16777216。</td></tr><tr><td><span class="inline">buffer_u64</span></td><td> 8</td><td><br/>一个64位无符号整数值。 <b>（当前不受所有缓冲区功能的支持！）</b></td></tr><tr><td><span class="inline">buffer_f64</span></td><td> 8</td><td><br/>一个64位浮点数。</td></tr><tr><td><span class="inline">buffer_bool</span></td><td> 1个</td><td><br/>布尔值。只能是1或0（<tt>true</tt>或者 <tt>false</tt>）</td></tr><tr><td><span class="inline">buffer_string</span></td><td>不适用</td><td><br/>这是UTF-8空终止（0x00）字符串。基本上，将<span class="notranslate">GameMaker</span>字符串转储到缓冲区中，并在末尾添加0。</td></tr></tbody></table><p></p><p>因此，假设您已经创建了一个缓冲区并且想要向其写入信息，那么您将使用类似以下代码的内容：</p><p class="code">buffer_write(buff, buffer_bool, global.Sound);<br/> buffer_write(buff, buffer_bool, global.Music);<br/> buffer_write(buff, buffer_s16, obj_Player.x);<br/> buffer_write(buff, buffer_s16, obj_Player.y);<br/> buffer_write(buff, buffer_string, global.Player_Name);</p><p>查看上面的示例，您可以看到可以同时将不同类型的数据写入缓冲区（使用<em>快速</em>缓冲区类型时，您仅限于特定的数据类型），并且此数据将被添加到缓冲区中顺序（尽管其在缓冲区中的实际位置将取决于其字节对齐，如下所述）。对于从缓冲区读取信息也是如此，在上述示例中，您将以与写入数据相同的顺序从缓冲区读取数据，并检查相同的数据类型，例如：</p><p class="code">global.Sound = buffer_read(buff, buffer_bool);<br/> global.Music = buffer_read(buff, buffer_bool);<br/> obj_Player.x = buffer_read(buff, buffer_s16);<br/> obj_Player.y = buffer_read(buff, buffer_s16);<br/> global.Player_Name = buffer_read(buff, buffer_string);</p><p>如您所见，您以与将其读入缓冲区的顺序读出信息。有关如何在缓冲区中添加和删除数据的更多信息，请参见下面的示例。</p><p>如果您已通读此页面，则将看到有关缓冲区<strong>字节对齐的参考。</strong>这基本上是指新数据将存储在给定缓冲区内的位置。这是如何运作的？好吧，对于单字节对齐的缓冲区，每个数据段都被顺序写入缓冲区，每个新数据段都在前一个之后直接添加。但是，一个2字节对齐的缓冲区会将每个数据写入2字节的间隔，因此，即使您的初始写入是1字节数据，下一次写入也将被移动以对齐两个字节：</p><p><img alt="Buffer Byte Alignment" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Buffer_Byte_Alignment.png" />因此，如果您将字节对齐方式设置为4个字节，并且您写了一个大小为1字节的数据，则执行缓冲区<strong>告诉</strong>（一条tell命令获取缓冲区读取/写入的当前位置），你会得到一个1个字节（在这种情况下偏移字节从缓冲区当前读/写位置的起始数）的<strong>偏移</strong>。</p><p>但是，如果您写入另一段大小也为1字节的数据，<em>然后</em>执行缓冲区告诉，则由于对齐已填充了数据，您将获得5字节的偏移量（即使您仅写入了2字节的数据）。将其与4字节缓冲区对齐方式对齐。</p><p>基本上，这意味着对齐只会影响<em>将</em>内容写入的位置，因此，如果您在写入内容后执行缓冲区告诉操作，它将返回当前写入位置，该位置紧随先前写入的数据之后。但是请注意，如果您随后写入另一条数据，则缓冲区将在内部实际写入数据之前将写入位置移至对齐大小的下一个倍数。</p><p>下面我们有几个示例，说明如何在项目中使用缓冲区：</p><p></p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">缓冲区检查点</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot">该函数的一个简单示例说明了如何在适用于<span class="notranslate">GameMaker Studio 2</span> <a href="../GameMaker_Language/GML_Reference/General_Game_Control/game_save_buffer.htm"><span class="inline">game_save_buffer()</span></a> 。此功能将获取当前游戏状态的“快照”，并将其保存到预定义的缓冲区中，然后可以从中读取该缓冲区以再次加载该游戏。</p><p class="note"><strong>注意</strong>：此功能非常有限，仅供初学者快速启动并运行检查点系统，但由于游戏无法保存，因此更高级的用户可能更喜欢使用File功能编写自己的系统代码。您可以在运行时创建的任何动态资源，例如数据结构，表面，添加的精灵等。</p><p class="dropspot">我们需要做的第一件事是创建一个新对象来控制保存和加载，因此您将创建一个对象并为其<strong>创建Create Event</strong> 。在这种情况下，您可以放置以下代码：</p><p class="code">SaveBuffer = buffer_create(1024, buffer_grow, 1);<br/> StateSaved = false;</p><p class="dropspot">第一行创建一个1024字节并对齐1字节的增长缓冲区（因为我们不知道保存数据的最终大小）。然后创建一个变量来检查并查看游戏是否已保存（将用于加载）。</p><p class="dropspot">接下来，我们将添加一个<strong>Keypress事件</strong>（例如），其中将当前游戏状态保存到创建的缓冲区中：</p><p class="code">StateSaved = true;<br/> buffer_seek(SaveBuffer, buffer_seek_start, 0);<br/> game_save_buffer(SaveBuffer);
    </p><p class="dropspot">上面将首先将控制变量设置为 <span class="inline">true </span>（以便在将游戏保存到缓冲区时将其保存），然后在将当前保存状态写入缓冲区之前查找缓冲区的开始。我们为什么使用<a href="../GameMaker_Language/GML_Reference/Buffers/buffer_seek.htm"><span class="inline">buffer_seek()</span></a> ？好了，正如本页已经提到的那样，您从向其添加数据的最后一个位置读取和写入缓冲区。这意味着如果您没有将缓冲区设置回告诉开头，那么当您保存时，您将在当前缓冲区的读/写位置将数据添加到缓冲区中。因此，我们使用功能 <span class="inline">buffer_seek()</span>将告诉移动到缓冲区开始。</p><p class="dropspot">现在，我们将当前游戏状态保存到缓冲区中。下一步可能是编码如何加载它，可能是在另一个<strong>Keypress事件中</strong>：</p><p class="code">if StateSaved<br/>    {<br/>    buffer_seek(SaveBuffer, buffer_seek_start, 0);<br/>    game_load_buffer(SaveBuffer);<br/>    }</p><p class="dropspot">然后，在您放置上述代码的事件结束时，将加载游戏。</p><p class="note"><strong>注意</strong>：这仅用于同一房间，而不用于在关闭或重新启动游戏后生成完整的保存游戏！</p><p class="dropspot">要添加到控制器对象的最后一件事是一些“清理”代码。缓冲区存储在内存中，因此，如果在使用完缓冲区后仍不清理缓冲区，可能会导致内存泄漏，最终导致游戏滞后并崩溃。因此，您可能会添加一个<strong>Room End事件</strong>（来自<strong>Other</strong>事件类别）：</p><p class="code">buffer_delete(SaveBuffer);</p><p class="dropspot">现在可以将该对象放置在房间中，并按一下键保存并从缓冲区中加载房间状态。</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">网络缓冲区</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot">在使用<span class="notranslate">GameMaker Studio 2</span><a href="../GameMaker_Language/GML_Reference/Networking/Networking.htm">网络功能时</a>，您必须使用缓冲区来创建通过网络连接发送的数据包。本示例旨在说明如何完成此操作，但是由于联网的可能性，它仅旨在说明如何使用缓冲区本身，而不是整个网络系统。</p><p class="dropspot">我们将展示的第一件事是为网络连接的客户端创建和使用缓冲区。该缓冲区将用于创建小的数据包，然后将其发送到服务器，因此在<strong>实例的Create Event</strong>中，我们将分配一个缓冲区，如下所示：</p><p class="code">send_buff = buffer_create(256, buffer_grow, 1);</p><p class="dropspot">我们将缓冲区变小（256字节）-因为它不打算容纳大量数据-然后我们将其设为增长缓冲区，以确保在任何时候都需要添加更多要发送的数据的情况下确保没有错误，并且对齐为方便起见，将其设置为1。</p><p class="dropspot">现在，假设我们希望客户端将数据发送到服务器。为此，我们需要创建一个缓冲区“ packet”，在本示例中，我们将发送一个<strong>Key Press Event</strong> ，就像当玩家按下<em>向左箭头</em>在游戏中移动时一样。为此，我们首先将必要的数据写入缓冲区，然后将其发送出去：</p><p class="code">buffer_seek(buff, buffer_seek_start, 0);<br/> buffer_write(buff, buffer_u8, 1);<br/> buffer_write(buff, buffer_s16, vk_left);<br/> buffer_write(buff, buffer_bool, true);<br/> network_send_packet(client, buff, buffer_tell(buff));</p><p class="dropspot">在写入缓冲区之前，我们已将“ tell”设置为缓冲区的开头，因为网络始终会从缓冲区的开头获取数据。然后，我们写入检查值（服务器将使用该值来确定要处理的事件的类型），然后是所使用的键，然后是键的状态（在这种情况下，为true）。然后，网络功能将此缓冲区作为数据包发送。请注意，我们不会发送整个缓冲区！我们仅使用buffer_tell函数发送写入的数据，以返回缓冲区的当前读/写位置（请记住，写入缓冲区会将“ tell”移动到已写入内容的末尾）。这仅仅是为了避免发送过多的字节。</p><p class="dropspot">如何在服务器上接收数据呢？接收到的数据包必须先写入服务器上的缓冲区中，然后才能用于更新游戏。为此，我们将<a href="../The_Asset_Editors/Object_Properties/Async_Events.htm">在服务器的网络控制器对象中使用网络异步事件</a>，如下面的简化代码所示：</p><p class="code">var buff = ds_map_find_value(async_load, &quot;buffer&quot;);<br/> if cmd == buffer_read(buff, buffer_u8);<br/>    {<br/>    key = buffer_read(buff, buffer_s16);<br/>    key_state = buffer_read(buff, buffer_bool);<br/>    }</p><p class="dropspot">异步事件将包含一个特殊的临时DS映射 <span class="inline">async_load</span>（在事件结束时自动将其从内存中删除），其中包含不同的信息，具体取决于来自网络的传入数据的类型。在这种情况下，我们假设已经检查了映射，发现映射是从客户端发送的缓冲区数据包。现在，我们检查缓冲区中的第一条数据，以查看发送了哪种事件-在这种情况下，值“ 1”表示键事件，但是，在编码这些内容时，应定义常量以将这些值保存为简化事情-然后存储被按下的键及其状态（<span class="inline">true</span> =按下， <span class="inline">false</span> =已发布）。然后，此信息将用于使用发送客户端播放器的新状态更新所有客户端。</p><p class="note"><strong>注意</strong>：从DS映射创建的缓冲区将在网络异步事件结束时自动删除，因此此处无需使用<span class="inline" style="font-size: 14px">buffer_delete（）</span> 。 </p><p class="dropspot"></p></div><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">返回：<a href="Additional_Information.htm">其他信息</a></div><div style="float:right">下一页：<a href="Bitwise_Operators.htm">按位运算符</a></div></div></div><h5><span data-keyref="Copyright Notice">©版权所有<span class="notranslate">YoYo Games Ltd.</span> 2021保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
Buffers
Using Buffers
-->
  <!-- TAGS
using_buffers
-->
</body>
</html>