<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>数组</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="页面概述数组" />
  <meta name="rh-index-keywords" content="数组" />
  <meta name="search-keywords" content="数组" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>数组</h1><p>数组可能非常有用，并且是制作游戏的重要组成部分。如果没有数组，这只是几件事是不可能的（或者至少要困难得多）：</p><ul class="colour"><li>菜单。一两个数组可以使创建良好的菜单系统更加容易。</li><li>角色扮演游戏。数组对于制作RPG必不可少，因为您不需要乱七八糟的变量，而只有几行，可以随时引用。</li><li>纸牌游戏。非常适合跟踪卡和手。</li><li>高分和其他统计数据。与多个变量相比，跟踪一个数组要容易得多。</li></ul><p>这只是冰山一角，因为数组是您可以使用的最基本，最有用的编程工具之一，并且您会对它们可以拥有的应用程序感到惊讶！它们还具有很高的内存效率，并且通常可以快速解析，因此非常适合于最大限度地提高性能。</p><p><label for="aone">基本数组被分类为具有1<strong>维</strong>，但是您也可以具有多个维。以下各节对两种类型的数组进行了详细说明：</label></p><p></p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">一维数组</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot">在继续之前，让我们先弄清楚数组的实际含义和结构。数组只是<a href="Data_Types.htm">分配给变量的一种数据类型</a>，它不仅可以包含一个值，还可以包含多个值。下图显示了基本数组的示意图：</p><p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png" /></p><p class="dropspot">这称为一<strong>维</strong>（一维）数组，如您所见，该数组存储在变量“<span class="inline">a</span>并包含多个值。要访问该数组，您需要执行以下操作：</p><p class="code">var _val = a[0];<br/> show_debug_message(_val);
    </p><p class="dropspot">上面的代码从数组“ a”的位置0获取值，然后将其输出到控制台，该控制台-根据上图所示数组的内容-将输出125。如果执行以下操作：</p><p class="code">var _val = a[3];<br/> show_debug_message(_val);
    </p><p class="dropspot">输出将显示“ Hi！”。</p><p class="dropspot">如您所见，您为数组指定了一个变量名，然后在方括号中指定了一个值 <span class="inline">[]</span>，其中值是从中获取数据的数组中的位置。因此，从本质上讲，数组是一个具有多个用于存储值的空间的容器，并且容器中的每个位置都有一个用于标识它的特定数字，这就是我们将其放入 <span class="inline">[]</span>。值得注意的是，数组的内容<b>总是从0开始，</b><i>永远不能为负</i>！</p><p class="dropspot">我们已经展示了如何检查数组中的数据，但是如何创建数组呢？首先，必须先对其进行<i>初始化，</i>然后才能使用它，否则<span class="notranslate">GameMaker Studio 2</span>将给我们一个错误。初始化数组只是意味着我们为数组的每个位置提供一个初始值，以准备在项目代码中的其他地方使用它。要记住这一点很重要，因为这意味着在使用数组之前必须做一些计划，但是使用像这样的重复循环初始化一个就很容易了...</p><p class="code">var i = 9;<br/> repeat(10)
      <br/>     {
      <br/>     array[i] = 0;<br/>     i -= 1;<br/>     }
    </p><p class="dropspot">这个简单的代码将初始化一个10阵列的位置（从0至9）保持0，即：阵列中的每个位置的值为0。您会注意到该阵列已经<i>向后</i>初始化，与最后的值被首先定义。这不是严格必要的，但是是实现此目的的最佳方法，因为它将在内存中保留一个恰好是数组大小的空间，而如果从0<em>向上</em>初始化数组，则必须为每个内存重新分配内存。增加的附加值（因此，对于十项数组，在循环中对其进行初始化将使内存分配更改十次）。对于较小的阵列，速度差异可以忽略不计，但是应该以这种方式尽可能地优化较大的阵列。</p><p class="note"><b>注意</b>：HTML5导出是上述规则的例外，并且在定向时，您应该从0到0的连续顺序初始化数组。</p><p class="dropspot">您还可以使用<span class="notranslate">GML</span>函数 <a href="../GML_Reference/Variable_Functions/array_create.htm"><tt>array_create()</tt></a>将数组初始化为固定大小，甚至可以创建<em>没有</em>值的“空”数组，例如：</p><p class="code">my_array= [];</p><p class="dropspot">这告诉<span class="notranslate">GameMaker</span>变量“ my_array”是一个数组，然后您可以在将来的任何时候向其添加值。但是，如果尝试访问空数组中的值，则会收到错误消息。实际上，您应该始终只访问有效的数组位置，因为尝试访问数组外部的值也会产生错误。例如，这将导致项目在运行时崩溃：</p><p class="code">my_array = array_create(5, 0);<br/> var _val = my_array[6];</p><p class="dropspot">数组仅使用5个位置进行初始化，但我们尝试获取位置7-数组从0开始编号，因此 <span class="inline">array[6]</span>是位置7-因此游戏会产生错误并崩溃。</p><p class="dropspot">我们已经展示了如何为每个位置使用相同的值初始化和数组，但是如果我们想为每个位置使用不同的值初始化数组怎么办？为此，我们必须手动键入每个位置，但是有一个很好的技巧可以帮助我们跟踪那里的情况：</p><p class="code">var _count = 3;<br/> array[_count] = &quot;you?&quot;<br/> count -= 1;<br/> array[_count] = &quot;are &quot;<br/> count -= 1;<br/> array[_count] = &quot;How &quot;<br/> count -= 1;<br/> array[_count] = &quot;Hello!&quot;<br/> count -= 1;</p><p class="dropspot">如您所见，我们在实际数组中未使用任何数字，而是使用<a href="Variables/Local_Variables.htm">局部变量</a>来递减这些值。这非常有用，特别是对于较大的数组，因为这意味着您不必跟踪有多少个位置，也不必跟踪哪个位置，因为代码将为您照管。您只需要知道数组必须拥有多少个总位置即可。</p><p class="dropspot">最后，您可以使用单个变量调用将值分配给数组，如下所示：</p><p class="code">var _a = [0, 1, 2, 3, 4];<br/> var _b = [];</p><p class="dropspot">上面的代码将创建两个数组作为局部变量，第一个数组已填充了5个元素，第二个数组已作为准备添加值的空数组。</p><p class="dropspot">完成后，我们如何将数组用于实际的事情？与使用普通变量完全相同，如以下示例所示：</p><p class="code">// Add two array values together<br/> total = array[0] + array[5];<br/>
      <br/> // Check an array value<br/> if (array[9]) == 10<br/>     {
      <br/>     //do something<br/>     }
      <br/>
      <br/> // draw an array value<br/> draw_text(32, 32, array[3]);</p><p class="dropspot">由于数组是连续编号的，这意味着您也可以遍历它们以执行额外的操作，就像我们初始化它一样：</p><p class="code">var total = 0;<br/> for (var i = 0; i &lt; 10; ++i;)<br/>     {
      <br/>     total += array[i];<br/>     draw_text(32, 32 + (i * 32), array[i]);<br/>     }
      <br/> draw_text(32, 32 + (i * 32), total);</p><p class="dropspot">上面的代码将把我们数组中的所有值加起来，画出每个值，最后画出总值。</p><p class="dropspot">关于数组的最后一件事是，您也可以简单地通过“重新分配”将其定义为单个值的变量来删除数组。这将释放与该数组的所有位置和值关联的内存。例如：</p><p class="code">//Create the array for (var i = 9; i &gt; -1; --i;)<br/>     {
      <br/>     a[i] = i;<br/>     }
      <br/> //Delete the array<br/> a = -1;</p><p class="dropspot">如果数组具有多个维度（请参见下文），它们也将全部清除，并请注意，当您在实例中创建数组时，从游戏中删除该实例时无需清理这些数组，因为在销毁或房间末端<a class="glossterm" data-glossterm="垃圾收集器" href="#">由垃圾收集器</a>自动删除。但是，如果任何的阵列位置的保持到<em>动态</em>资产引用-样颗粒的系统，缓冲剂，或数据结构-然后这些<em>将</em>需要被销毁之前阵列被删除或实例被破坏，或室的端部。</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">多维数组</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot"><span style="text-align: justify;">我们知道一维数组是什么，但是在<span class="notranslate">GameMaker Studio 2</span>您可以拥有具有多个维的数组，这些数组本质上是作为数组内部的数组内部的数组构造的。例如，以下是<strong>2D</strong> （二维）大批</span></p><p class="code"><span style="text-align: justify;"></span>array[0][0] = 5;</p><p class="dropspot">这实际上是在告诉<span class="notranslate">GameMaker</span> ，该数组实际上是由各种1D数组组成的。这是一个扩展的示例：</p><p class="code">array[1][2] = 1;<br/> array[1][1] = &quot;hello&quot;;<br/> array[1][0] = 55.5;<br/> array[0][2] = sprite_index;<br/> array[0][1] = &quot;world&quot;;<br/> array[0][0] = -67.89;</p><p class="dropspot">多维数组需要在使用前进行初始化，与单个1D数组相同，并且可以容纳实数，字符串和任何其他<a href="Data_Types.htm">数据类型</a>（就像任何变量一样），使其成为需要存储的任何游戏的理想选择。以易于访问的方式存储大量数据（请记住，您可以轻松地遍历数组）。这是一个如何在实际游戏中使用的最终示例。假设您想根据随机值在游戏的四个不同点生成四个不同的敌人。好吧，我们可以使用2维数组来完成此操作，并节省编写代码的负担。</p><p class="dropspot">首先，我们应该初始化将在“控制器”对象的create事件中使用的数组（请注意使用注释来提醒您每个数组条目的作用）：</p><p class="code">enemy[3][2] = 448;       //y position<br/> enemy[3][1] = 32;        //x position<br/> enemy[3][0] = obj_Slime; //Object<br/> enemy[2][2] = 448;<br/> enemy[2][1] = 608;<br/> enemy[2][0] = obj_Skeleton;<br/> enemy[1][2] = 32;<br/> enemy[1][1] = 608;<br/>      enemy[1][0] = obj_Knight;<br/> enemy[0][2] = 32;<br/> enemy[0][1] = 32;<br/> enemy[0][0] = obj_Ogre;</p><p class="dropspot">现在，我们有了对象来生成房间的实例，它们在房间内的相应x和y生成坐标都存储在数组中。现在可以在控制器对象的另一个事件（例如，警报或按键事件）中按如下方式使用它：</p><p class="code">//get a random number from 0 to 3, inclusive<br/> var i = irandom(3);<br/> //Use the array to create the object<br/> instance_create_layer(enemy[i][1], enemy[i][2], &quot;Enemy_Layer&quot;, enemy[i][0]);</p><p class="dropspot">现在，该短代码将在游戏室中产生一个随机敌人，并且使用的代码远少于“<tt>if / then / else</tt> “结构甚至是“<tt>switch</tt> ”，并且在create事件中将数组一起初始化时，由于这些值没有被<a class="glossterm" data-glossterm="硬编码" href="#">硬编码</a>到项目代码的其余部分中，因此更容易编辑和更改这些值。</p><p class="dropspot">还要注意，数组中每个维度的长度可以不同，因此您可以将初始数组维度的长度设置为3，但是对于每个初始数组值，第二个维度条目的长度可以不同它被分配给，例如：</p><p class="code">array[2][2] = &quot;3&quot;;<br/> array[2][1] = &quot;2&quot;;<br/> array[2][0] = &quot;1&quot;;<br/> array[1][3] = &quot;four&quot;;<br/> array[1][2] = &quot;three&quot;;<br/> array[1][1] = &quot;two&quot;;<br/> array[1][0] = &quot;one&quot;;<br/>      array[0][1] = 2;<br/> array[0][0] = 1;</p><p class="dropspot">最后，多维阵列不限于<em>只有</em>两个维度，并且可以有3个，4个或更多维度的阵列作为在代码需要，只是通过加入 <span class="inline">[n]</span>其他参数，例如：</p><p class="code">array[0][0][0] = 1;     // A three dimensional array<br/> array[0][0][0][0] = 1;  // A four dimensional array<br/> // etc...</p></div><p></p><p>就像普通变量一样，您可以将数组传递给<a href="Script_Functions.htm">脚本函数</a>和<a href="Method_Variables.htm">要使用的方法变量</a>，然后返回到调用该函数的实例。为此，您只需指定数组变量（不需要每个单独的位置，也不需要 <span class="inline">[]</span>括号），整个数组将<b>通过引用传递</b>到函数中。但是，如果您更改任何数组值，则该数组将被复制到仅用于该函数<em>的临时数组中。</em><strong>注意这里使用<i>临时</i>一词！</strong>您实际上并没有将数组本身传递给函数（就像将变量传递给函数一样），而是要求函数创建<i>此数组的副本</i>，您将对其进行更改。这意味着，如果您想更改任何数组值<b>，则必须始终</b><em>从函数返回数组（此行为称为“写时复制</em>”）。</p><p class="note"><b>注意：</b>由于这种内部工作方式，将数组传递给函数可能会影响性能，尤其是在数组很大的情况下。因此，请谨慎使用此功能！</p><p>例如，请考虑以下代码。首先，我们创建要使用的数组，然后将该数组传递给函数：</p><p class="code">for (var i = 9; i &gt; -1; --i;)<br/>     {
    <br/>     a[i] = i;<br/>     }
    <br/> my_array_func(a);
  </p><p>该函数本身很简单，例如：</p><p class="code">my_array_func = function(array)<br/>     {
    <br/>     for (var i = 9; i &gt; -1; --i;)<br/>         {
    <br/>         array[i] = i * 100;<br/>         }
    <br/>     }
  </p><p>现在，你会想到最后数组来保存值900，800，700，等...但这不会是这样，因为我们<i>没有</i>返回从函数数组，所以我们改变是临时副本，这是当我们将数组作为参数传递给函数时创建的，而当函数完成时，它基本上也消失了。为了解决这个问题，我们应该将代码格式化如下：</p><p class="code">for (var i = 9; i &gt; -1; --i;)<br/>     {
    <br/>     a[i] = i;<br/>     }
    <br/> a = my_array_func(a);</p><p>现在，该函数应如下所示：</p><p class="code">my_array_func = function(array)<br/>     {
    <br/>     for (var i = 9; i &gt; -1; --i;)<br/>         {
    <br/>         array[i] = i * 100;<br/>         }
    <br/>     return array;<br/>     }
  </p><p class="note"><b>注：</b>以上是<b>没有</b>必要的，如果你不改变任何数组值，而只是引用它们。引用数组不会复制它，并且解析起来会更快。</p><p>还值得注意的是，您可以使用访问器 <tt>@</tt>从函数引用数组并直接更改其值，这节省了将其复制到函数中的CPU开销。您可以从以下页面找到有关访问器及其工作方式的更多信息，以及数组示例：</p><ul class="colour"><li><a href="Accessors.htm">存取器</a></li></ul><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">背面： <a href="GML_Overview.htm"><span class="notranslate">GML</span>概述</a></div><div style="float:right">下一页：<a href="Data_Types.htm">数据类型</a></div></div></div><h5><span data-keyref="Copyright Notice">©版权所有<span class="notranslate">YoYo Games Ltd.</span> 2021保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
Arrays
passing arrays to scripts
deleting arrays
-->
  <!-- TAGS
arrays
-->
</body>
</html>