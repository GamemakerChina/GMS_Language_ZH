<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>顺序</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="该页面概述了与序列相关的不同功能和变量" />
  <meta name="rh-index-keywords" content="" />
  <meta name="search-keywords" content="顺序" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>顺序</h1><p>序列通常是在IDE中使用“<a href="../../../../The_Asset_Editors/Sequences.htm">序列编辑器”</a>创建的，但是也可以使用代码来创建和编辑。但是，在查看可用功能之前，重要的是要了解<span class="notranslate">GameMaker</span>中定义序列的方式以及将要使用的不同术语。</p><p>首先，您需要在顶层拥有一个<b>sequence元素</b>。这是您通过“房间编辑器”或使用适当的<a href="../Rooms/Sequence_Layers/Sequence_Layers.htm">图层功能在代码中放置在房间的图层上的内容</a>。图层元素除了元素ID值外没有其他实际属性，但是使用上述图层功能更改序列回放或访问序列数据时，此ID是必需的。</p><p>接下来，您将拥有<b>序列对象</b>和<b>序列实例</b>，就像拥有一般对象和实例一样。序列<i>对象</i>是您在<b>资源浏览器中</b>创建的或使用函数的基础资源 <a href="sequence_create.htm"><tt>sequence_create()</tt></a>，序列<i>实例</i>是该序列对象的“副本”，该对象已作为层上的元素放置在房间中。将序列对象视为蓝图，将序列实例视为根据这些蓝图创建的对象。序列对象和实例是<a href="../../../GML_Overview/Structs.htm">结构，</a>并且-与常规对象不同-序列对象结构可以在<span class="notranslate">runtime</span>进行编辑，当您将其创建为元素时，它将影响该序列的所有其他实例（并且<b>不会</b>重置对序列对象所做的任何编辑通过重新启动游戏或房间 <tt>room_restart()</tt>或者 <tt>game_restart()</tt>功能）。序列实例结构包含一些用于控制播放和事物的参数（下面将对此进行详细说明）以及<b>序列数据</b>结构。</p><p>最后，如上所述，您拥有<b>序列数据</b>，这是另一个结构。该结构包含有关序列的<i>所有数据。</i>它包含的曲目，这些曲目具有的属性，播放速度等等。下面概述了该结构内容的确切细节，但主要由<b>资产跟踪</b>结构和<b>参数跟踪</b>结构组成，它们使用<b><span class="notranslate">keyframe</span>数据</b>在序列播放时实际执行操作。</p><p>序列元素使用房间<a href="../Rooms/Sequence_Layers/Sequence_Layers.htm">层功能处理</a>，但是对于序列对象，实例和数据，我们具有以下功能： </p><p></p><ul class="colour"><li><a href="sequence_exists.htm">sequence_exists</a></li><li><a href="sequence_create.htm">sequence_create</a></li><li><a href="sequence_destroy.htm">sequence_destroy</a></li><li><a href="sequence_get.htm">sequence_get</a></li><li><a href="sequence_track_new.htm">sequence_track_new</a></li><li><a href="sequence_keyframe_new.htm">sequence_ <span class="notranslate">keyframe</span> _new</a></li><li> <a href="sequence_keyframedata_new.htm">sequence_ <span class="notranslate">keyframe</span> _新</a></li><li><a href="sequence_get_objects.htm">sequence_get_objects</a></li><li><a href="sequence_instance_override_object.htm">sequence_instance_override_object</a></li></ul><p></p><p>还有一个<strong>与实例相关联的内置变量</strong>，可用于确定实例是否已按顺序使用：</p><p></p><ul class="colour"><li><a href="in_sequence.htm">in_sequence</a></li></ul><p class="note"><strong>重要的！</strong>如果您的序列中包含任何实例，则这些实例不应更改其实例<span class="inline"><span style="font-size:14px;">image_xscale</span>/<span class="inline"><span style="font-size:14px;">image_yscale</span> / <span
      class="inline"><span style="font-size:14px;">image_angle</span></span> /<span class="inline"><span style="font-size:14px;">x</span> /<span class="inline"><span style="font-size:14px;">y</span>变量，因为在开始播放后序列更新每个步骤时，它们将被覆盖。</p><p></p><p>在使用这些功能创建或编辑序列之前，建议您阅读下面给出的有关结构属性的详细说明。有关如何创建新序列的一般概述为：</p><ul class="colour"><li>使用函数创建新的序列对象 <a href="sequence_create.htm"><tt>seqeunce_create()</tt></a>并将序列对象索引存储在变量中。该索引使您可以访问序列对象struct。</li></ul><p class="code">myseq = sequence_create();</p><ul class="colour"><li>设置序列对象的顶级值，例如长度，播放模式，播放速度等。例如：</li></ul><p class="code">myseq.length = 120;<br/> myseq.loopmode = seqplay_pingpong</p><ul class="colour"><li>在将音轨添加到序列对象之前，您需要创建它们，因此，您现在需要创建一个由该函数定义<i>的资产音轨数组。</i><a href="sequence_track_new.htm"><tt>sequence_track_new()</tt></a> 。请注意，在代码中，资产轨道和参数轨道之间实际上没有区别-它们都是简单的轨道，它们的行为方式取决于您创建的轨道的类型以及是否将它们作为子轨道分配给顶级轨道或不是。因此，您将为资产创建一个轨道，然后为其分配不同参数的子轨道，这些子轨道将充当该资产<i>的参数轨道。</i>下面的示例创建一个图形资产轨迹，该轨迹将在以后添加到序列中：</li></ul><p class="code">var mytracks = array_create(1);<br/> mytracks[0] = sequence_track_new(seqtracktype_graphic);</p><ul class="colour"><li>每个资产轨道都需要一些数据来告诉序列其外观或位置等，并以<i><span class="notranslate">keyframes</span></i>的形式添加。在资产跟踪的顶层，您可以<span class="notranslate">keyframes</span> （在下面的“跟踪结构”部分中列出），但是请注意，由于它们是资产跟踪<span class="notranslate">keyframes</span> ，因此不会被插值，而只会更改达到给定帧时引用的值。每个<span class="notranslate">keyframe</span>都是添加到数组的结构，然后将此数组分配给资产跟踪。要创建<span class="notranslate">keyframe</span>结构，我们将调用该函数 <a href="sequence_keyframe_new.htm"><tt>sequence_keyframe_new()</tt></a>并<span class="notranslate">keyframe</span> ，我们将使用 <a href="sequence_keyframedata_new.htm"><tt>sequence_keyframedata_new()</tt></a>：</li></ul><p class="code">// Create a new keyframe struct for a graphics asset track and add it to an array (as you can have multiple keys in a frame)<br/> var graphickeys = array_create(1);<br/> graphickeys[0] = sequence_keyframe_new(seqtracktype_graphic);<br/> // Set the graphics
    keyframe top level data for the keyframe position and length, etc...<br/> graphickeys[0].frame = 0;<br/> graphickeys[0].length = 1;<br/> graphickeys[0].stretch = true;<br/> graphickeys[0].disabled = false;<br/> // Create the channel data that will
    go into this keyframe (again an array, as each key can have multiple channels of keyframe data)<br/> var graphickeydata = array_create(1);<br/> graphickeydata[0] = sequence_keyframedata_new(seqtracktype_graphic);<br/> graphickeydata[0].spriteIndex
    = spr_Platform;<br/> graphickeydata[0].channel = 0;<br/> // Add the keyframe data channels to the graphics track keyframe<br/> graphickeys[0].channels = graphickeydata;<br/> // Add the definied keyframes to the track<br/> mytracks[0].name = &quot;TestGraphicTrack&quot;;<br/>    mytracks[0].keyframes = graphickeys;</p><ul class="colour"><li>现在，我们需要创建一个参数轨道，将其作为子轨道分配给刚刚创建的图形轨道。这将以与上面所示类似的方式完成，只是现在我们需要为轨道指定一个名称，以显示其目的，在本例中为“位置”，因为我们将使用该轨道在整个路线上移动图形轨道序列动画帧的数量：</li></ul><p class="code">// Create a new parameter track struct for the position of the graphic<br/> var paramtracks = array_create(1);<br/> paramtracks[0] = sequence_track_new(seqtracktype_real);<br/> paramtracks[0].name = &quot;position&quot;;<br/> paramtracks[0].interpolation
    = true;<br/> // Create the keyframe struct to hold the parameter channel data and set the frame position for the keyframe<br/> var paramkeys = array_create(2);<br/> paramkeys[0] = sequence_keyframe_new(seqtracktype_real);<br/> paramkeys[0].frame =
    0;<br/> paramkeys[1] = sequence_keyframe_new(seqtracktype_real);<br/> paramkeys[1].frame = 120;<br/> // Create the keyframe data structs<br/> var paramkeydata1 = array_create(2);<br/> paramkeydata1[0] = sequence_keyframedata_new(seqtracktype_real);<br/>    paramkeydata1[0].channel = 0; // Channel 0 for a position track is the X position<br/> paramkeydata1[0].value = 0;<br/> paramkeydata1[1] = sequence_keyframedata_new(seqtracktype_real);<br/> paramkeydata1[1].channel = 1; // Channel 1 for a position
    track is the Y position<br/> paramkeydata1[1].value = 0;<br/> var paramkeydata2 = array_create(2);<br/> paramkeydata2[0] = sequence_keyframedata_new(seqtracktype_real);<br/> paramkeydata2[0].channel = 0;<br/> paramkeydata2[0].value = room_width;<br/>    paramkeydata2[1] = sequence_keyframedata_new(seqtracktype_real);<br/> paramkeydata2[1].channel = 1;<br/> paramkeydata2[1].value = room_height;<br/> // Assign the keyframe data structs to the channels for each key<br/> paramkeys[0].channels = paramkeydata1;<br/>    paramkeys[1].channels = paramkeydata2;<br/> // Assign the keys to the parameter track<br/> paramtracks[0].keyframes = paramkeys;</p><ul class="colour"><li>完成之后，最后要做的是将参数轨道作为子轨道分配给我们在开始时创建的主要图形资产轨道，然后将这些轨道分配给序列，然后我们可以在房间中创建一个实例：</li></ul><p class="code">mytracks[0].tracks = paramtracks;<br/> myseq.tracks = mytracks;<br/> layer_sequence_create(&quot;Assets_1&quot;, 0, 0, myseq);</p><p>上述指令创建绘制在<i>序列的</i>（0，0）位置上的子画面一个非常简单的序列对象，然后将其移动到在一个循环中右下角和背部。如前所述，您需要在许多地方访问不同的结构以提供或获取有关序列的数据，下面的部分列出了这些结构包含的所有不同属性：</p><ul class="colour"><li><a name="object"></a><a href="Sequence_Structs/The_Sequence_Object_Struct.htm"><label for="1">序列对象结构</label></a></li><li><a name="instance"></a><a href="Sequence_Structs/The_Sequence_Instance_Struct.htm"><label for="2">序列实例结构</label></a></li><li><a name="track"></a><a href="Sequence_Structs/The_Track_Struct.htm"><label for="3">轨道结构</label></a></li><li><a name="keyframe"></a><a href="Sequence_Structs/The_Keyframe_Struct.htm"><label for="4"><span class="notranslate">Keyframe</span>结构</label></a></li><li><a name="keyframe_data"></a><a href="Sequence_Structs/The_Keyframe_Data_Struct.htm"><label for="5"><span class="notranslate">Keyframe</span>数据结构</label></a></li></ul><p></p><p>最终，可以将代码添加到序列中，从而可以将其作为<strong>瞬间</strong><strong>事件</strong>或<strong>广播消息</strong>来触发。以下页面将对此进行详细说明：</p><ul class="colour"><li><a href="Sequence_Events_Moments_Broadcast.htm">事件，时刻和广播消息</a></li></ul><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">返回：<a href="../Asset_Management.htm">资产管理</a></div><div style="float:right">下一页：<a href="../Fonts/Fonts.htm">字体</a></div></div></div><h5><span data-keyref="Copyright Notice">©版权所有<span class="notranslate">YoYo Games Ltd.</span> 2021保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
Sequences
-->
  <!-- TAGS
sequence_functions
-->
</body>
</html>