<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>抽奖活动</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="详细说明绘制事件的页面。" />
  <meta name="rh-index-keywords" content="对象-绘制事件" />
  <meta name="search-keywords" content="抽奖活动,画画开始,画完,预画,抽签后,绘制GUI,签单" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>抽奖活动</h1><p><img alt="The Draw Event" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_Draw.png" />绘画事件类别是具有所有事件的类，该事件控制着您在运行游戏时在屏幕上看到的内容。它分为多个单独的事件，以更好地满足您游戏的不同绘画要求，下图说明了每个事件的执行顺序：</p><p><img alt="Object Editor Draw Diagram" class="center" src="../../assets/Images/Asset_Editors/Editor_Events_DrawOrder.png" />普通的Draw事件分为三个子类型： <strong>Draw Begin</strong> ，标准<strong>Draw</strong>和<strong>Draw End</strong>事件。通常，您只需要使用标准的Draw事件，并且您应该知道房间中的所有实例都会在游戏的每个步骤触发此事件，因此只要实例具有<strong>可见的外观，便始终会调用此事件。</strong>标志设置为true。重要的是要理解，即使您没有在对象属性中为该子事件定义任何内容（即，没有代码或动作），<em>如果为对象分配了精灵，则它将仍然具有将触发的draw事件</em>。这是因为<span class="notranslate">GameMaker Studio 2</span>具有两种在Draw事件中绘制内容的方式：</p><ul class="colour"><li><strong>默认绘制</strong>，即您在对象属性中定义精灵，并且在常规Draw事件中不放置任何动作或代码时，在这种情况下， <span class="notranslate">GameMaker Studio 2</span>将自动绘制分配的精灵。请注意，只要绘制事件为空，您在其他事件中执行的任何更改图像缩放比例，索引，混合等的变换都将反映出来。</li><li><strong>自定义draw</strong> ，这是您在draw事件中放置代码或动作时的情况。这是告诉<span class="notranslate">GameMaker Studio 2</span> “<em>我想控制您为该对象实例绘制的内容</em>”，它会完全覆盖默认绘制。这意味着，例如，你可以有分配一个精灵的对象，然后设置抽奖活动，以绘制文本和文本将在屏幕上绘制，但你还没有告诉精灵将<em>无法</em>绘制<span class="notranslate">GameMaker Studio 2</span>将其与文本一起绘制。</li></ul><p>其余的绘制事件将在下面列出的部分中进行说明：</p><p></p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">绘制开始和绘制结束</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot">除了主要的Draw事件外，您还具有<strong>Draw Begin</strong>和<strong>Draw End</strong>事件。它们的行为与标准Draw事件的行为完全相同（即：它们将在游戏的每个步骤以及所有视口中绘制您放置在其中的任何内容），但是如果未将其明确添加到屏幕上，则它们不会“默认绘制”任何内容对象，它们将始终在标准Draw事件之前/之后运行。因此，在游戏运行时，您将<em>始终</em>对所有实例具有Draw Begin事件，然后对所有实例均具有Draw事件，最后对于所有实例均具有Draw End事件。</p><p class="dropspot">这样，您可以在一个实例的“绘制开始”步骤中绘制事物或设置绘制属性，并确保所有具有标准Draw事件或Draw End事件的实例都将使用这些属性或绘制第一个实例所绘制的内容。基本上，这是一种确定的方法，可以确保在某些时间绘制某些内容，就像“<strong>开始步骤”</strong>和“<strong>结束步骤”</strong>事件一样。</p><p class="dropspot"> <span class="notranslate">GameMaker Studio 2</span>绘制时，需要注意一些事项，无论是要绘制的精灵还是<span class="notranslate">shader</span> ，还是3D缓冲区：</p><ul class="colour"><li class="dropspot">绘制事件是一个非常密集的事件，因为它是占用大量时间和资源的事件之一……为此，在绘制事件中除了绘制以外，不做任何事情都是一个好主意。因此，请为Step事件或Alarms或其他适合的事件保存大型代码或复杂的操作，但是请为图形保留draw事件，因为这样做才是最好的。</li><li class="dropspot">如果您的对象的visible参数设置为<em>off</em> （以便不绘制该对象的实例），则将<strong>跳过所有绘制事件</strong>（“<strong>调整大小”</strong>事件除外）。这意味着使实例不可见将阻止运行任何这些事件中的所有代码，因此，如果基本代码不可见，请不要将其放入绘图事件中。</li><li class="dropspot">绘制的内容与您选择的碰撞引擎（传统的或物理的）无关，这是由对象属性和已赋予对象的精灵（或蒙版）定义的。</li></ul><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">绘制GUI</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot"> Draw GUI事件类型属于Draw Event类别，并且是专门为不受视图摄像机比例或旋转影响的<a class="glossterm" data-glossterm="图形用户界面" href="#">图形GUI元素设计的。</a>这意味着您可以让实例为<a class="glossterm" data-glossterm="平视显示器" href="#">HUD</a>或用户界面绘制所有元素，而不必将元素的所有位置都基于房间内的实例位置或当前摄像机视图的位置。</p><p class="dropspot">在这种情况下进行绘制时，重要的是要了解即使在摄像机视图处于活动状态时绘制坐标也不会改变，并且（0,0）<em>始终</em>是应用程序表面或显示屏的左上角（请参见此部分的底部），并且应用程序表面的默认宽度和高度为1：1。深度顺序仍然保持在不同层上的不同实例之间（因此，较高层的实例将被绘制在较低层的一个实例之下）以及事件本身内，因为<strong>Draw GUI Begin</strong>事件将首先为所有实例绘制，然后标准的<strong>Draw GUI</strong>将为所有实例<strong>绘制，最后触发Draw Gui End</strong>事件。</p><p class="dropspot">这样，您可以在一个实例中的Draw GUI Begin中绘制事物或设置draw属性，并确保具有标准Draw GUI或Draw GUI End事件的所有实例都将使用这些属性或覆盖第一个实例绘制的内容。基本上，这是一种确保在特定时间绘制某些内容的肯定方法，就像“<strong>开始步骤”</strong>和“<strong>结束步骤”</strong>事件一样。</p><p class="dropspot">这些事件也可以与正常的Draw事件一起使用（正常情况下，Draw事件将受到摄像机视图位置，比例和旋转的影响）。如果您没有Draw事件，但确实有Draw GUI事件，则<span class="notranslate">GameMaker Studio 2</span>仍将照常默认为该实例绘制精灵（如果有）。</p><p class="dropspot">相对于其他绘制事件，Draw GUI事件将始终覆盖正常绘制事件中绘制的所有内容。因此，如果您在较低层上有一个带有Draw GUI事件的实例，则它将通过常规绘图事件在较高层上的实例上进行绘制。如果两个实例都具有Draw GUI事件，则将遵守图层顺序。</p><p class="note"><strong>注意</strong>：默认情况下，此事件将使用应用程序表面尺寸（通常是房间或视口的尺寸）绘制1：1。这意味着，当您<strong>在“游戏选项”中启用了“宽高比校正”</strong>时，将不会在“字母框”游戏的黑条上绘制GUI。 <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_maximise.htm"><span style="font-size:14px;"><span class="inline" style="font-size: 14px">可以使用display_set_gui_maximise（）</span></span></a>函数关闭此行为，并且还可以将GUI事件锁定为特定大小，然后使用<a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_size.htm"><span class="inline" style="font-size: 14px">display_set_gui_size（）</span></a>函数自动将其缩放以适合显示或应用程序表面尺寸。</p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">抽签前后</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot">Draw Pre和Post Draw事件是Draw Event类别的一部分。但是，与其他Draw事件不同，这些事件<em>直接</em>吸引到<a class="glossterm" data-glossterm="显示缓冲区" href="#">显示缓冲区</a>，它将是当前可见的所有视口的合并屏幕空间的大小，<em>或者</em>如果仅使用一个视口或根本不使用任何视口，则为窗口大小。下图说明了这一点：</p><p class="dropspot"><img alt="Object Editor Post Draw" class="center" src="../../assets/Images/Asset_Editors/Editor_Object_PostDraw.png" />因此，如果您使用Pre或Post绘制事件，则将绘制到全屏渲染目标（显示缓冲区），该目标的大小将与所有视口都适合的窗口的大小相同。如果没有活动的视口，则将其设置为窗口本身的大小。</p><p class="dropspot"> Pre Draw事件在任何其他draw事件之前触发，您可以在其中设置值，设置draw属性甚至绘制东西，而不必担心视口或GUI层的大小（GUI层的大小可能与屏幕缓冲区，但可能不是，因为您可以在代码中设置GUI分辨率。</p><p class="dropspot">值得注意的是，此事件发生<em>在</em>清除常规图形的显示缓冲区之前，这意味着如果不关闭房间编辑器中的视图清除功能，则在Pre Draw事件中绘制的任何内容都不会被看到，这是第一个视口绘制会清除它。如果您希望能够自己查看视口，或者根本不使用视口，那么还应该在“<strong><a href="../Rooms.htm">房间编辑器”</a></strong>中将背景色设置为Alpha为0。</p><p class="note"><strong>注意</strong>：如果关闭这些选项，则在测试游戏时，您可能会注意到屏幕上绘制了不必要的伪影（例如实例中的“拖尾”）。这是因为您直接在显示缓冲区的前一帧上绘制而未清除它。但是，您可以使用<span class="inline" style="font-size: 14px"><a href="../../GameMaker_Language/GML_Reference/Drawing/Colour_And_Alpha/draw_clear_alpha.htm">draw_clear_alpha（）</a></span>自己执行此操作。</p><p class="dropspot"><em>在</em>所有标准绘图事件之后但<em>在</em>Draw GUI事件之前触发Post Draw事件。与Pre Draw事件类似，它基于显示缓冲区的大小，并置于Draw GUI事件之前，使您能够简单，轻松地在不干扰任何<a class="glossterm" data-glossterm="平视显示器" href="#">HUD的情况下以全屏方式执行后处理效果和其他操作。</a> /游戏中可能包含的<a class="glossterm" data-glossterm="图形用户界面" href="#">GUI元素。</a></p><p class="dropspot"></p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">调整视窗大小</a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot">此事件类型属于“绘制事件”类别，尽管它实际上并未绘制任何内容，但它确实对显示缓冲区中的更改做出了反应-特别是，它设计用于在游戏窗口时对UWP显示缓冲区大小的更改做出反应。是“快照”。</p><p class="dropspot">在UWP目标平台上，重要的是您要从游戏窗口的“捕捉”中捕获显示缓冲区的任何大小调整（例如，当用户将窗口拖动到显示器的侧面时）。此事件将执行此操作，并在每次更改窗口时触发该事件，允许您在此处添加自定义代码，该代码将调整视图的大小或根据需要<a class="glossterm" data-glossterm="平视显示器" href="#">重新定位HUD元素。</a>提供此功能是避免步骤事件代码始终检查这些事件的便捷方法。</p><p class="note"><strong>注意</strong>：您不能参加此活动！它是通过调整窗口大小来触发的，并且仅用于捕获此更改...应进行的任何绘制仍必须处于其他绘制事件之一中。 </p><p class="dropspot"></p></div><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">返回：<a href="Object_Events.htm">对象事件</a></div><div style="float:right">下一页：<a href="Async_Events.htm">异步事件</a></div></div></div><h5><span data-keyref="Copyright Notice">©版权所有<span class="notranslate">YoYo Games Ltd.</span> 2021保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
Draw Events
Pre Draw Event
Post Draw Event
Draw Begin Event
Draw End Events
Draw GUI Events
Draw GUI Begin Event
Draw GUI End Event
Pre Draw Event
Post Draw Event
Window Resize Event
-->
  <!-- TAGS
draw_events
-->
</body>
</html>