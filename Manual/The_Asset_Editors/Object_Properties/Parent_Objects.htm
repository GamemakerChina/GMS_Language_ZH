<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>父对象</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing object parenting" />
  <meta name="rh-index-keywords" content="Objects - Parents" />
  <meta name="search-keywords" content="parent,child,inheritance,object parenting" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>父对象</h1>
  <p>在<span class="notranslate">GameMaker Studio 2</span>IDE中处理对象时，你可以设置<strong>父 </strong>/子层次结构。这可以通过点击对象编辑器中的 &quot;父 &quot;按钮来实现，然后从资产浏览器中选择另一个对象
    作为正在编辑的对象的 &quot;父&quot;。</p>
  <p><img alt="Adding A Parent" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_Parent.png">那么，你的游戏项目中的每个对象都可以有一个父对象，但这意味着什么？嗯，当一个对象有一个父对象的时候，它可以
    与该父对象共享代码、动作和事件。这种共享被称为 &quot;继承&quot;，一个有父对象的对象被称为 &quot;子 &quot;对象。子对象不仅可以与它的父对象共享代码，而且你可以对父对象进行检查和运行代码
    父对象上做检查和运行代码，它也会自动包括子对象，这节省了大量的时间和精力。</p>
  <p>如果这听起来很复杂，那么另一种看待父对象的方式是将对象 &quot;分组 &quot;在同一伞下，让它们共享某些东西而不失去它们自己的独特身份。也许这仍然不能
    澄清了一些事情，所以让我们举一些例子......</p>
  <p>假设你有一个 &quot;玩家 &quot;对象和四个不同的 &quot;敌人 &quot;对象。现在，你想让玩家在碰到这四个对象中的任何一个时死亡，这通常需要四个不同的碰撞事件和四套不同的
    这通常需要四个不同的碰撞事件和四套不同的动作或代码，每个敌人对象都有一个。但是，如果我们为所有的敌人制作一个父对象，那么我们就可以只与父对象创建一个碰撞事件，无论四个 &quot;子 &quot;敌人中的哪一个，它都会触发
    对象中的哪一个接触到玩家，它都会被触发。很方便的东西!在实际的<span class="notranslate">GameMaker Studio 2</span>对象中，你会看到像这样的东西。</p>
  <p><img alt="Parenting For Collisions" class="center" src="../../assets/Images/Asset_Editors/Editor_Object_ParentCollision.png">在左边我们有四个独立的碰撞事件，在右边我们有一个单一的碰撞事件，因为我们已经创建了一个
    &quot;父 &quot;对象，并将所有的敌人对象分配给它。请注意，一个父对象不需要有任何事件或代码在里面...</p>
  <p>父代的另一个例子是，如果你有一个游戏，你想创建10个不同外观的对象，并让它们都以同样的方式行事。为此，你将创建一个父对象，并在其中设置所有的行为动作或代码
    在所需的事件中，然后你将创建十个没有动作或代码的对象，但有不同的精灵，并将它们分配给你的父对象。现在，当你把这些实例放在一个房间里时，它们的行为都是一样的，但看起来却不同。
    因为它们将 &quot;继承 &quot;父对象的事件。</p>
  <p>最后，你可以用养育法来 &quot;混合和匹配 &quot;事件和行为。我们将用一个最后的例子来说明这一点...假设你想要两个怪物：一个可以上下移动，另一个可以左右移动，但你还想让这两个怪物有相同的健康状况，向玩家射击，并在碰撞时伤害玩家。
    但你还希望它们有相同的健康状况，向玩家射击，并在玩家与它们相撞时伤害玩家。在这种情况下，你可以看到几乎所有的事件都应该有相同的动作，除了一两个支配移动的事件。所以，同样，我们可以让
    一个对象是另一个对象的父对象，但在这种情况下，我们也为子对象定义了某些事件。这些事件 &quot;覆盖 &quot;了父对象的事件，这意味着只要子对象的事件包含动作，这些动作就会被执行
    而不是在父对象的事件中包含的动作。如果你也想执行父事件，你可以使用函数调用所谓的 &quot;继承的 &quot;事件 <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a>,
    或<span class="notranslate">DnD</span>™动作<a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">Call Parent Event</a>。</p>
  <p><img alt="Inheriting Events" class="center" src="../../assets/Images/Asset_Editors/Editor_Object_InheritEvents.png">上面的左边是父对象，里面有5个事件，右边你可以看到 &quot;子 &quot;对象。子对象
    也有5个事件，但其中两个覆盖了从父对象继承的事件（<strong>Step </strong>和<strong>Draw </strong>事件），另外三个是灰色的，因为它们是从父对象继承的事件。继承的事件
    也会在事件编辑器中的旁边有 &quot;父级覆盖 &quot;的图标。</p>
  <p><img alt="Parent Override" class="center" src="../../assets/Images/Asset_Editors/Editor_Object_ParentOverride.png">当你在一个已经被继承的事件上点击<img alt="LMB Icon" class="icon" src="../../assets/Images/Icons/Icon_LMB.png"> 。
    它将打开代码编辑器，显示继承的父级代码，但你将不能编辑这段代码，因为你只能在父级对象本身中编辑它。你可以在任何一个父事件上单击鼠标右键<img alt="RMB Icon" class="icon" src="../../assets/Images/Icons/Icon_RMB.png"> ，打开以下选项菜单。</p>
  <p><img alt="Parent Event RMB Menu" class="center" src="../../assets/Images/Asset_Editors/Editor_Object_Parent_Menu.png">这里你可以选择两个<strong>打开 </strong>父事件来检查代码，或者你可以选择<strong>继承 </strong>该
    事件或<strong>覆盖 </strong>该事件。如果你选择 "继承"，那么代码编辑器就会打开，其中的函数 <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a>已经
    添加到其中（如果使用<span class="notranslate">DnD</span>™，则为<a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">调用父事件</a>动作）。你在这个事件中放置的任何进一步的代码现在将和父对象的代码一样被运行。
    的代码。如果你选择<strong>覆盖 </strong>事件，那么代码窗口也会打开，只是现在 <span class="inline">event_inherited()</span> 函数不会被调用，所以你在这里添加的任何东西都会被运行<em>，而不是 </em>父对象中的代码
    父对象中的代码。</p>
  <p class="note"><strong>注意</strong>：在代码编辑器中，你可以通过点击鼠标右键<img alt="RMB Icon" class="icon" src="../../assets/Images/Icons/Icon_RMB.png"> ，并从弹出的菜单中选择<strong>转到对象</strong>，快速导航到父对象，或者（如果事件已经被覆盖）你可以选择<strong>打开继承事件</strong>，直接进入包含父事件代码的代码编辑器。</p>
  <p>每当你在代码中以一个父对象为目标时，代码也将适用于父对象的 &quot;子&quot;。当你在一个动作中指出该动作必须应用于某个对象的实例时，就会发生这种情况，而在代码中，当你使用
    发生在你使用 <a href="../../GameMaker_Language/GML_Overview/Language_Features/with.htm"><span class="inline">with()</span></a>语句时发生。当你调用代码函数时，也会像这样工作，例如 <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_position.htm"><span class="inline">instance_position()</span></a>,
    <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_number.htm"><span class="inline">instance_number()</span></a>等......其中--如果你提供了一个父对象--所有的<em>父和子 </em>实例的实例
    将被包括在检查中。最后，当你引用其他对象中的变量时，父子关系也会起作用，比如在上面的怪物例子中，如果我把敌人1的速度设置为10，那么敌人2的速度也会变成10，因为它是敌人的一个子对象
    1.</p>
  <p>一般认为，在大多数情况下，创建一个基本的父对象，并让这个基本对象包含所有的默认行为，但在游戏中永远不要使用它的实例，这是一个很好的做法。相反，使用所有的子对象，并且只在以下情况下使用父对象
    情况下才使用父对象，如我上面所概述的，用于碰撞，用于引用变量等等。你也应该意识到，父对象也可以有母对象！你可以在游戏中使用母对象。显然，你不能创建一个 &quot;父对象1是父对象2的孩子是父对象1的孩子 &quot;的循环。
    1的孩子 &quot;的循环，但你可以创建所谓的 &quot;对象层次结构&quot;，即 &quot;parent3是<em>parent2 </em>的孩子，是<em>parent1的孩子&quot; </em>。这对保持你的游戏结构非常有用，我们强烈建议你学会使用这种机制。
    强烈建议你学习使用这种机制。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">返回。<a href="../Objects.htm">对象编辑器</a></div>
        <div style="float:right">下一步。<a href="Physics_Objects.htm">物理学对象</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span>版权所有。2021年 保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
Parent Objects
Child Objects
parent
child
inheritance
-->
  <!-- TAGS
parent_objects
-->
</body>
</html>