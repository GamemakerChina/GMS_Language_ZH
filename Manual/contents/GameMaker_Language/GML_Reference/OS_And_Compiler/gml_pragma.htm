<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>gml_pragma</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference page for gml_pragma" />
  <meta name="rh-index-keywords" content="gml_pragma" />
  <meta name="search-keywords" content="gml_pragma" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>gml_pragma</h1>
  <p> <tt>gml_pragma</tt>函数会影响给定目标如何编译你的代码，并且应该与不同的命令一起调用，以进一步优化你项目的最终编译。这些命令在游戏编译前有效地<i>进行了预处理</i>。
    游戏编译之前进行有效的预处理，因此该函数可以放在项目的任何地方，它仍然会在游戏完全编译之前被处理。可用的命令如下。</p>
  <ul class="colour">
    <li>&quot;<b>forceinline&quot; -</b> 当在脚本函数中用 &quot;forceinline &quot;pragma调用该函数时，<b>YYC将</b>以内联方式<b>编译</b>该函数，而不是引用。这将进一步提高处理
      但在使用时必须小心，因为它也会增加最终可执行文件的大小，特别是当内联代码很大和/或在多个不同地方使用时，还会大大增加编译时间。请注意，这个语法
     <b>只在使用YYC构建时有效</b>。</li>
    <li><b>&quot;global&quot;, &quot;</b>[gml code]&quot; -<b>&quot;global</b>&quot; pragma允许你在编译时<span class="notranslate">，</span>在游戏的第一个房间执行之前，在全局范围内调用一些格式化为字符串的GML代码。比如说<br>
     <p class="code">gml_pragma(&quot;global&quot;, &quot;Init()&quot;)。</p>
      这将在游戏的第一个房间运行之前调用脚本函数 &quot;Init&quot;。请注意，作为第二个参数提供的<span class="notranslate">GML</span> <b>必须是一个编译时的常量</b>，同时也请注意，你不能使用这个pragma来创建实例
      或执行任何需要房间（或房间里的任何东西）发挥作用的操作。</li>
    <li>&quot;<b>PNGCrush&quot; -</b>&quot;PNGCrush&quot; pragma 将在创建的<a href="https://pmt.sourceforge.io/pngcrush/" target="_blank">每个</a>纹理上使用 PNGCrush 程序。请注意，这可能会大大增加编译游戏的时间。
      的时间，所以你不希望一直使用它，尽管它可以大大节省最终文件的大小。</li>
    <li>&quot;<b>Texgroup.Scale&quot;, &quot;</b>[<b>TextureGroupName]&quot;, &quot;[Scale Div</b>isor]&quot; -<b>&quot;Texgroup.Scale &quot;</b>将在编译时缩放给定的纹理组。你需要在这里给出另外两个参数：&quot;[TexGroupName]&quot;。
      是要缩放的纹理组的名称（一个字符串），以及&quot;[Scale Divisor]&quot;（也是一个字符串），这是你希望用于缩放的除数，即<br>
     <p class="code">gml_pragma(&quot;Texgroup.Scale&quot;, &quot;level1&quot;, &quot;2&quot;)。</p>
      这将使 &quot;level1 &quot;纹理组中的所有纹理减半。</li>
    <li>&quot;<b>UnityBuild&quot;, &quot;</b>[enable/disable<b>]&quot; - 如果你</b>用这个pragma<b>调用函数</b>，并将enable/disable参数设置为true，那么在编译时，<tt>它会</tt>将项目中所有的.cpp文件折叠成一个文件
      然后用它来构建所有的东西，比如说。<br>
     <p class="code">gml_pragma(&quot;UnityBuild&quot;, &quot;true&quot;)。</p>
      使用unity build的好处是构建速度更快，但缺点是它每次都会进行<i>完整的</i>构建，所以即使你改变了代码的一个部分，它也会重新构建所有的内容，而不会使用任何缓存文件。这一点是
      是专门为使用YYC的Xbox One导出而添加的，尽管它可以为其他构建调用<b>（仅YYC</b>）。关于unity构建的更多信息，请看<a href="http://buffered.io/posts/the-magic-of-unity-builds/" target="_blank">这里</a>。</li>
  </ul>
  <p class="note"><b>注意</b>：<tt>gml_pragma</tt>函数的第一个参数<b>必须是一个编译时的字符串常数</b>，而不是一个变量。</p>
  <p> </p>
  <h4>语法。</h4>
  <p class="code">gml_pragma(command, [optional...])。</p>
  <table>
    <tbody>
      <tr>
        <th>争论</th>
        <th>描述</th>
      </tr>
      <tr>
        <td>指挥部</td>
        <td>一个字符串，包含下列命令之一。</td>
      </tr>
      <tr>
        <td>[可选]</td>
        <td>一些可用的命令需要一个或多个可选的参数。下面将对每个命令进行解释。</td>
      </tr>
    </tbody>
  </table>
  <p> </p>
  <h4>返回。</h4>
  <p class="code">不适用</p>
  <p> </p>
  <h4>例子。</h4>
  <p class="code">gml_pragma(&quot;forceinline&quot;)。</p>
  <p>上面的示例代码将强制在编译时将使用的脚本函数内联。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">回来了。<a href="OS_And_Compiler.htm">操作系统和编译器</a></div>
        <div style="float:right">下一页:<a href="parameter_count.htm">参数_计数</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span>版权所有。2021年 保留所有权利</span></h5>
  </div>
  <!-- KEYWORDS
gml_pragma
-->
  <!-- TAGS
gml_pragma
-->
</body>
</html>